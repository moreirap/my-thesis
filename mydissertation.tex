%\documentclass[dissertation,draft]{softeng}
\documentclass[dissertation,final]{softeng}

\usepackage{enumitem} % allows reducing space between items

%\usepackage{ifdraft} % Contain macros to determine if document class has draft option or not

\usepackage{etoolbox}
%\newtoggle{chapterone}
%\newtoggle{chaptertwo}
%\newtoggle{chapterthree}
%\ifdraft
%{
%        \toggletrue{chapterthree}
%        \toggletrue{chapterone}
%        \toggletrue{chaptertwo}
%}{
%    \togglefalse{chapterthree}
%    \togglefalse{chapterone}
%    \togglefalse{chaptertwo}
%}

% \togglefalse{workingmode}
% 

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{times}
\usepackage{mathptmx}
\usepackage[utf8]{inputenc}

\usepackage[backend=biber,
            hyperref=false,
            natbib=true,
            citestyle=authoryear,
            bibstyle=authoryear-comp,
            url=false,
            isbn=false,
            doi=false,
            dashed=false,
            maxcitenames = 2, 
            mincitenames = 1, 
            maxbibnames = 3,
            firstinits = true,
            labelyear=true,  
            uniquename=false, 
            uniquelist=false,
            terseinits = false]{biblatex}

\addbibresource{mydissertation.bib}
\setlength\bibitemsep{1.5\itemsep}

\title{Extending BDD\\A systematic approach to handling non-functional requirements}
\author{Pedro Moreira}
\college{Kellogg College}
\organisation{University of Oxford}
\award{Software Engineering}

\usepackage[english, status=draft]{fixme}
\fxusetheme{color}

\usepackage{xspace}
\newcommand{\nfrs}{non-functional requirements\xspace}
\newcommand{\Nfrs}{Non-functional requirements\xspace}

\usepackage[english]{babel}
\usepackage[autostyle=true,english=british]{csquotes}
\SetCiteCommand{\citep}


\usepackage{pgfplotstable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage{graphicx} %package to manage images
\graphicspath{ {Images/} {Images/case_study/} }


\colorlet{tableheadcolor}{gray!25} % Table header colour = 25% gray
\newcommand{\headcol}{\rowcolor{tableheadcolor} \bfseries} %he
\colorlet{tablerowcolor}{gray!10} % Table row separator colour = 10% gray
\newcommand{\rowcol}{\rowcolor{tablerowcolor}} %
    % Command \midline consists of 3 rules (top colour tableheadcolor, middle colour black, bottom colour white)
\newcommand{\midline}{
            \arrayrulecolor{tableheadcolor}\specialrule{\aboverulesep}{-1pt}{0pt}%
            \arrayrulecolor{black}\specialrule{\lightrulewidth}{0pt}{0pt}%
            \arrayrulecolor{white}\specialrule{\belowrulesep}{0pt}{-3pt}%
            \arrayrulecolor{black}
            }
\usepackage{multirow}
            
\uchyph=0 % Prevent hyphenation of all uppercase words (normally acronyms)

\usepackage[outputdir=Temp,newfloat=true,cache=false]{minted}
\setminted[gherkin]{frame=none,
                    framesep=0mm,
                    fontsize=\footnotesize,
                    baselinestretch=1.2,
                    samepage=true,
                    stripnl=false,
                    obeytabs=false,
                    tabsize=4}
\usemintedstyle{bw}

% ignore minted parsing errors
\makeatletter
\expandafter\def\csname PYGdefault@tok@err\endcsname{\def\PYGdefault@bc##1{{\strut ##1}}}
\makeatother

\SetupFloatingEnvironment{listing}{name=Source Code / Feature}
\SetupFloatingEnvironment{listing}{listname=List of Source Code / Features}

\usepackage{tikz}

\def\tikzmark#1{\tikz[remember picture,overlay]\coordinate(#1);}

% Used for Listings of Features
\newsavebox{\featurebox} 
\newenvironment{featurecode}[1]
{ \lrbox\featurebox \begin{adjustbox}{width=#1\textwidth,minipage=\textwidth,margin=1cm 0 0 0,inner} }
{ \end{adjustbox}\endlrbox}

\newenvironment{featurelist}[2]
{
\newcommand{\setcaption}{\caption{#1}}
\newcommand{\setlabel}{\label{#2}}
}
{\begin{listing}[h!]\centering\usebox\featurebox\setcaption\setlabel\end{listing}}

\usepackage{caption}

\usepackage{adjustbox}

\usepackage{relsize} % Package for font resizing

\usepackage[toc,page]{appendix} % package to add appendixes and list them in table of contents

\usepackage{longtable}  % As the name says, supports tables that span multiple pages

%\renewcommand\listoflistingscaption{List of source code}
%\renewcommand{\listingscaption}{Source code}

\setcounter{LTchunksize}{50}

\begin{document}
\expandafter\def\csname PY@tok@err\endcsname{}
\maketitle


\begin{abstract}
Software engineering methods have evolved from having a prescribed and sequential nature to using more adaptable and iterative approaches. Such is the case with Behaviour Driven Development (BDD), a recent member of the family of agile methodologies addressing the correct specification of the behaviour characteristics of a system, by focusing on close collaboration and identification of examples.

Whilst BDD is very successful in ensuring that developed software meets its functional requirements, it is largely silent regarding the systematic treatment of its non-functional counterparts, descriptions of how the system should behave with respect to some quality attribute such as performance, reusability, etc.

Historically, the systematic treatment of non-functional requirements (NFRs) in software engineering is categorised as being either product-oriented and based on a quantitative approach aimed at evaluating the degree to which a system meets its NFRs, or process-oriented, qualitative in nature and used to drive the software design process. Examples of the latter category, are the NFR Framework -- a structured approach to represent and reason about non-functional requirements -- and the goal-oriented requirements language (GRL) that provides support for evaluation and analysis of the most appropriate trade-offs among (often conflicting) goals of stakeholders. 

In this thesis, we investigate the extent to which goal-oriented principles can be integrated in BDD, with the aim of handling non-functional requirements in an explicit and systematic way, whilst respecting the principles and philosophy behind agile development.
\end{abstract}

\clearpage

\begin{acknowledgements}
I would like to express my deepest gratitude to my supervisor, Dr Jeremy Gibbons, for his guidance, support, comments and encouragement.

I would also like to thank my family for their constant support and love, and in particular my wife, Tamara and my children Elijah and Indigo, for their endless patience whenever I so often disappeared into the office to research and write this thesis.

My sincere thanks to my mother who always encouraged and supported me through my studies and, more importantly, through all my life.

\emph{The author confirms that}: this dissertation does not contain material previously submitted for another degree or academic award; and the work presented here is the author's own, except where otherwise stated.
\end{acknowledgements}


\pagenumbering{roman}
\pagestyle{plain}
\setcounter{tocdepth}{2}

\tableofcontents

\listoffigures
\listoftables
\listoflistings

\pagenumbering{arabic}
\pagestyle{myheadings}

\chapter{Introduction}
\label{ch:Introduction}
This thesis presents an extension to Behaviour Driven Development~(BDD)~\citep{North2006,Smart201410} to support the elicitation, communication, modelling and analysis of non-functional requirements. It includes concepts and techniques from goal-oriented requirements engineering (GORE)~\citep{Lamsweerde:2001wpba}, and more specifically, allows the definition of goals in BDD and modelling and analysis in Goal Requirements Language (GRL)~\citep{Amyot2010}. This is achieved by integrating notions of goals in Gherkin~\citep{wynne2012cucumber} -- a domain specific language for the representation and specification of requirements. We also present a translator from Gherkin to GRL, allowing Gherkin-defined actors and goals satisfactions levels to be subject to qualitative and quantitative analysis in a GRL tool.

\section{Motivation}
The primary measure of success of a software system is the degree to which it meets the purpose for which it was intended~\citep{Nuseibeh:2000ub}. Shortcomings in the ways that people learn about, document, agree upon and modify such statements of intent are known causes to many of the problems in software development~\citep{Wiegers2013}. We informally refer to these statements of intent as Requirements and the engineering process to elicit, document, verify, validate and manage them as Requirements Engineering~\footnote{These topics will be explored in depth in Chapter~\ref{ch:Background}}.

The importance of requirements in software engineering cannot be understated. In his essay \emph{No Silver Bullet},~\citet{Brooks1987}, referring to the critical role of requirements to a software project, states that 
\blockcquote{Brooks1987}{The hardest single part of building a software system is deciding precisely what to build. No other part of the conceptual work is as difficult as establishing the detailed technical requirements, including all the interfaces to people, to machines, and to other software systems. No other part of the work so cripples the resulting system if done wrong. No other part is more difficult to rectify later.}

More recently, \citet{Davis200505} reveals that errors introduced during requirements activities account for 40 to 50 percent of all defects found in a software product.  When arguing for the importance of requirements, \citet{Hull2011} reason that to be well understood by everybody they are generally expressed in natural language and herein lies the challenge: to capture the need or problem completely and unambiguously without resorting to specialist jargon or conventions. The authors follow by positing that these needs may not be clearly defined at the start, may conflict or be constrained by factors outside their control or may be influenced by other goals which themselves change in the course of time.

Furthermore, requirements can be classified in multiple and at times conflicting ways. \citet{Glinz:2007ehba} points out that in every current classification scheme there is a distinction between requirements concerning the functionality of a system and all other, often referred to as non-functional requirements. In another paper, the same author points out issues with current classification schemes such as sub-classification, terminology and satisfaction level whereby some requirements are considered \emph{`soft'} in the sense that they can be weakly or strongly satisfied (e.g \emph{the system shall have a good performance}; or \emph{the System shall be secure}). \citet{Chung:2009vg} contribute that, in spite of this separation, most existing requirement models and requirements specification languages lack a proper treatment of non-functional requirements. In addition, this separation of functional and non-functional requirements has lead to the latter being either neglected, addressed later in a project or completely ignored. This problem applies to both traditional and agile software development processes. 

A software process is generically defined as a set of activities, methods, practices, and transformations that are used to develop and maintain software and its associated products~\citep{Cugola:1998htba}. Agile software development approaches have become more popular during the last few years. Several methods have been developed with the aim of delivering software faster and to ensure that the software meets customer changing needs. All these approaches share some common principles: Improved customer satisfaction, adopting requirements, frequently to changing delivering working software, and close collaboration of business people and developers~\citep{Paetsch:2003tl}.

One such agile approach is Behaviour Driven Development (BDD). The understanding of BDD is far from clear and unanimous~\citep{Solis0}. Some authors refer to BDD as a development process~\citep{Smart201410}, others state that it is not a fully fledged software development methodology but rather \textcquote{Adzic201106}{supplement other methodologies, provide rigour in specifications and testing, enhance communication between various stakeholders and members of software development teams, reduce unnecessary rework, and facilitate change}

In spite of the above mentioned differences of interpretation, it is unanimously accepted that BDD focus on deriving from  business goals a sufficient set of software features that contribute to achieve these business goals. This process makes use of Gherkin~\citep{wynne2012cucumber} -- a domain specific language which promotes the use of a ubiquitous language~\footnote{~Eric Evans first introduced that term in \citetitle{evans2004domain} \citet{evans2004domain}}  that business people can understand -- to describe and model a system. However the focus has been on functionality and quality characteristics such as performance, security, maintainability are not explicitly addressed. To the best of our knowledge, the single exception to the above, is the work of \citet{barmi2011automated}, but with restricted applicability to probabilistic -- those that can be written using probabilistic statements~\citep{grunske2008specification} -- non-functional requirements only.

None of these agile practices treat non-functional requirements in a systematic way, certainly not in a way that allows reasoning about which requirements interdependencies may exist, and the positive or negative influences each may have on each others. Among many proposals, goal-oriented approaches were the first to treat non-functional requirements as first-class citizens.~\citet{Mylopoulos:1999jh} observed that goal-oriented requirements engineering is generally complementary to other approaches and, in particular, is well suited to analysing requirements early in the software development cycle, especially with respect to non-functional requirements and the evaluation of alternatives. 

It seems only logical and expectable that, improvements to the discovery and communication of requirements, will lead to an increase in success rates of software projects.

\section{Aim and limitations of study}
The context described in the previous section justifies research aimed at capturing, documenting and communicating requirements using natural language tools and techniques in a precise, complete and unambiguous way, but also with the flexibility and adaptability to allow requirements to change and evolve through the course of time.

In this thesis, we investigate the extent to which goal-oriented principles can be integrated into BDD, with the aim of handling non-functional requirements in an explicit and systematic way, whilst respecting the principles and philosophy behind agile development. In particular, we consider how BDD can be extended, and also Gherkin modified, to incorporate actor and goal concepts as defined and treated in GRL.

We do not however investigate the integration of GRL with use case maps (UCM), as part of the User Requirements Notation~\citep{liu2004designing}. UCM targets modelling scenarios of functional or operational requirements and performance and architectural reasoning. This is left as an area for further research.

We also do not aim at providing another classification scheme and address the, sometimes artificial, separation of functional and non-functional requirements. Instead, we adopt the notion of goals as an objective the system under consideration should achieve and goal formulations as properties to be ensured. We share the view that goals cover different types of concerns: functional which are associated with the services to be provided, and non-functional concerns associated with quality of service such as safety, security, accuracy, performance, and so forth~\citep{Lamsweerde:2001wpba}.

Finally, we do not apply this technique to a specific non-functional requirement or restrict the validity of our results to any particular taxonomy, as our approach is independent of the \nfrs being addressed or taxonomy chosen.

\section{Significance of the study}

By reinterpreting behaviours in BDD as not just specifications of functionality of a system but as statements of goals, this thesis brings the following contributions to BDD:

\begin{center}
\begin{itemize}
\item Allows non-functional requirements to be specified in natural language form in Gherkin
\item Allows Gherkin specifications to be converted into goal models;
\item Allows BDD to consider all non-functional requirements relevant for a successful product delivery,not just those that are technical;
\item Brings to BDD the capability to assess qualitative and quantitative satisfaction levels of actors and goals.
\end{itemize}
\end{center}

By allowing goals to be elicited and specified in Gherkin, this thesis brings the following contributions to goal-oriented requirements engineering:

\begin{center}
\begin{itemize}
\item Allows goals elicitation to occur in Gherkin using natural language and therefore be more suitable for discussion and fostering communication;
\item Brings the benefits of executable specifications in BDD to goal formulations.
\end{itemize}
\end{center}


\section{Overview of contents}

The rest of the thesis is organised as follows:

Chapter~\ref{ch:Background} contains all the necessary background material related to requirements engineering, the approaches taken by agile processes and, in particular, an in-depth analysis of behaviour-driven development, describing the principles and practices of this popular agile process. Chapter~\ref{ch:nfr_research} presents an overview of the research concerning ways of handling non-functional requirements in software engineering and also a section on goal-oriented requirements engineering with a focus on GRL and with a description of jUCMNav~\citep{Amyot2010}, an editor for GRL models.

Chapter~\ref{ch:Extendingbdd} and chapter~\ref{ch:gherkin_redux} are the core of the thesis and contain details of extensions to Gherkin; mapping of Gherkin elements to GRL, such as actors and intentional elements; and a description of a translator from Gherkin to an XML-based interchange format containing GRL elements and links.

Chapter~\ref{ch:Extendingbdd} focuses on the practical uses of the extended methodology, while chapter~\ref{ch:gherkin_redux} exposes the technical details of the changes made to Gherkin and explains in detail the implementation of the translator from Gherkin to GRL.

Chapter~\ref{ch:Conclusion} contains implications of findings, concluding thoughts and related work, identifies limitations of study and suggests topics for future research.

\chapter{From traditional to agile requirements engineering}
\label{ch:Background}
In Chapter~\ref{ch:Introduction} we have outlined and situated our study around insufficiencies in current approaches to handling non-functional requirements in agile development methods, and behaviour-driven development in particular. 

In this chapter, we reflect on how fast-changing technology and increased competition are placing an ever increasing pressure on the development process. We first review the notions of requirements and requirements engineering, highlighting the most used processes and activities, regardless of the software development method in use. We follow with a description of requirements engineering practices in agile methods and finish with a presentation of key concepts of behaviour-driven development (BDD), contextualising BDD as an instance of \emph{Specification by Example}~\citep{Adzic201106}.

\section{Requirements}
\label{sec:requirements}
Despite decades of industry experience, many software organizations struggle to understand, document, and manage their product requirements. Inadequate user input, incomplete requirements, changing requirements, and misunderstood business objectives are major reasons why so many information technology projects are less than fully successful~\citep{Wiegers2013}. 

\subsection{Definition}
The difficulty with defining requirements, arises mostly due to a terminology problem. Different observers might describe a single statement as being a user requirement, software requirement, business requirement, functional requirement, system requirement, product requirement, project requirement, user story, feature, or constraint~\citep{Wiegers2013}. Because of the inter-connectedness of requirements with other aspects of systems engineering and project management, it is quite challenging to find a satisfactory scope for a definition of requirements engineering~\citep{Hull2011}. A typical definition of requirement can be found in ~\citefield{ieee_std_29148}{journaltitle}:
\begin{displayquote}
A statement that identifies a product or process operational, functional, or design characteristic or constraint, which is unambiguous, testable or measurable, and necessary for product or process acceptability (by consumers or internal quality assurance guidelines).
\end{displayquote}
It is worth breaking down this definition into its constituent words. A requirement comes mostly in a textual representation~(\emph{statement}) even though there are other complementary or alternative forms such visual forms, formal methods and domain specific languages. Requirements may define what is to be built in response to requirements~(\emph{product requirements}) but also procedures for using what will be built~(\emph{process requirements}). In addition, there may be requirements that stipulate how the product should be developed, usually for quality control purposes. The definition also allures for the existence of many different kinds of requirements, such as \emph{operational, functional, or design characteristic or constraint}, giving rise to different kinds of language, analysis, modelling, process and solution. It states that a requirement should lend itself to a clear, single understanding, common to all parties involved~(\emph{unambiguous}). It should also be quantifiable, thus providing a means of measuring and testing the solution against it. Finally, requirements play a multi-dimensional role and come from a multitude of sources. \citet{Sommerville:1997} shares a simpler, but nevertheless useful definition:
\begin{displayquote}
Requirements are a specification of what should be implemented. They are descriptions of how the system should behave, or of a system property or attribute. They may be a constraint on the development process of the system.
\end{displayquote}
This definition makes clear that different types of information are part of requirements domain. Requirements mean different things for different people: for users, they represent external characteristics of the system behaviour, whilst for developers, they are instead linked with internal characteristics. They include both the behaviour of the system under specific conditions and those properties that make it suitable -- and maybe even enjoyable -- for use by its intended users~\citep{Wiegers2013}.

\subsection{Classification}

\citet{Wiegers2013} provide a breakdown of different types of information that may be categorised as requirements. Given that the term `requirement' is extremely overloaded in software engineering, it is useful to give definitions of these information types (see table~\ref{tb:typesofreqs}). 

\begin{table}[h!]
\caption[Types of requirements information]{Types of requirements information~\citep{Wiegers2013}}
\label{tb:typesofreqs}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.75}{
\begin{tabularx}{\textwidth}{cX}
\toprule \multicolumn{1}{c}{\bfseries{Term}}&
\multicolumn{1}{c}{\bfseries{Definition}}\\
\addlinespace
\midrule
Business requirement & A high-level business objective of the organization that builds a product or of a customer who procures it\\ \midrule
Business rule &   A policy, guideline, standard, or regulation that defines or constrains some aspect of the business. Not a software requirement in itself, but the origin of several types of software requirements \\ \midrule
Constraint &    A restriction that is imposed on the choices available to the developer for the design and construction of a product \\ \midrule
External interface requirement &   A description of a connection between a software system and a user, another software system, or a hardware device \\ \midrule
Feature &    One or more logically related system capabilities that provide value to a user and are described by a set of functional requirements \\ \midrule
Functional requirement &    A description of a behaviour that a system will exhibit under specific conditions \\ \midrule
Non-functional requirement &  A description of a property or characteristic that a system must exhibit or a constraint that it must respect \\ \midrule
Quality attribute &    A kind of nonfunctional requirement that describes a service or performance characteristic of a product \\ \midrule
System requirement &    A top-level requirement for a product that contains multiple subsystems, which could be all software or software and hardware \\ \midrule
User requirement &    A goal or task that specific classes of users must be able to perform with a system, or a desired product attribute \\
\addlinespace
\bottomrule
\end{tabularx}
}
\end{table}

Figure~\ref{fig:types_of_requirements} depicts the relationships among these types of requirements information, using ovals for requirements and rectangles for documents. In the figure, solid arrows mean `are stored in'; dotted arrows mean `are the origin of' or `influence'.
\begin{figure}[h!]
\includegraphics[width=0.75\textwidth]{TypesOfRequirements}
\centering
\caption[Types of Requirements]{Relationships among several types of requirements information~\citep[p. 8]{Wiegers2013}}
\label{fig:types_of_requirements}
\end{figure}

Requirements can also be categorised as either \emph{product} or \emph{project} requirements. Product requirements are those that describe properties of a software system to be built. Projects certainly do have other expectations and deliverables that are not a part of the software the team implements, but that are necessary to the successful completion of the project as a whole. These are project requirements but not product requirements. An SRS houses the product requirements, but it should not include design or implementation details (other than known constraints), project or test plans, or similar information.

\citet{Hull2011} make an important distinction between requirements being defined in either a \emph{problem} or \emph{solution} domain. In the context of requirements existing at different layers of abstraction, those at higher layers, representative of statements of need, usage modelling and stakeholder requirements, pertain to the problem domain, whereas those in lower layers, starting with system requirements, operate in the solution domain. The use of multiple levels of abstraction promotes separation of concerns and allows views of stakeholders, analysts and developers to be taken in consideration.

\section{Requirements Engineering}
\label{sec:requirements_eng}
The \emph{\citefield{SWEBOK}{maintitle}}~(\citetitle{SWEBOK}, \citeyear{SWEBOK}) identifies topics that pertain to software requirements knowledge, which concern the elicitation, analysis, specification, and validation of software requirements as well as their management during the whole life cycle of a software product.

%\begin{figure}[h]
%\includegraphics[width=0.9\textwidth]{swebooksoftwarerequirements}
%\centering
%\caption[Topics for software requirements]{Topics for the Software Requirements knowledge area~(\citetitle{SWEBOK}, \citeyear{SWEBOK})}
%\label{fig:swebook_software_requirements}
%\end{figure}

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{swebooksoftwarerequirements}
\centering
\caption[Topics for software requirements]{Topics for the Software Requirements knowledge area~(\citetitle{SWEBOK}, \citeyear{SWEBOK})}
\label{fig:swebook_software_requirements}
\end{sidewaysfigure}

This section defines requirements engineering and breaks it down into its core processes and activities. We will not cover all topics contained in Figure~\ref{fig:swebook_software_requirements}, but instead focus on the more relevant ones, from the point of view of the work described in this thesis. 

\citet{Wiegers2013} argue that `the engineering aspect of requirements development and management, should not distract us from the fact that software development involves at least as much communication as it does computing, and yet we sometimes fail to appreciate that requirements engineering and, in particular, requirements elicitation -- and much of software and systems project work in general -- is primarily a human interaction challenge'. 

\subsection{Definition}
The definition in~\citefield{ieee_std_29148}{journaltitle} describes requirements engineering as an `interdisciplinary function that mediates between the domains of the acquirer and supplier to establish and maintain the requirements to be met by the system, software or service of interest. A vital part of the systems engineering process, requirements engineering first defines the problem scope and then links all subsequent development information to it~\citep{Hull2011}. One of the most long-standing definitions comes from a US Department of Defence software strategy document:

\begin{displaycquote}{united1991department}
Requirements engineering involves all life-cycle activities devoted to identification of user requirements, analysis of the requirements to derive additional requirements, documentation of the requirements as a specification, and validation of the documented requirements against user needs, as well as processes that support these activities.
\end{displaycquote}

A more recent definition emphasizes the goal-oriented nature of requirements engineering, and hints at the importance of understanding and documenting the relationships between requirements and other development artefacts:

\begin{displaycquote}{Zave:1997:CRE:267580.267581}
Requirements engineering is the branch of software engineering concerned with the real world goals for, functions of, and constraints on software systems. It is also concerned with the relationship of these factors to precise specifications of software behaviour, and to their evolution over time and across software families.
\end{displaycquote}

\citet{Hull2011} argues that both definitions omit the role that requirements play in accepting and verifying the solution. They propose an alternative definition:

\begin{displaycquote}{Hull2011}
Requirements engineering is the subset of systems engineering concerned with the discovery, development, trace, analysis, qualification, communication and management of requirements that define the system at successive levels of abstraction.
\end{displaycquote}

They argue that the above definition is a better reflection that requirements exist at multiple levels of development, and also list key activities that are considered proper to requirements engineering. Similarly to what we have done for the definition of requirement, it is worth breaking this definition into its constituent parts. \emph{Discovery}, refers to activities related to the elicitation and capture of requirements; \emph{trace} allows setting up links to and from requirements to other artefacts; \emph{qualification} refers to all kinds of testing activity and avoids the often confusing terms \emph{validation} -- checking formal expressions of requirements against informal needs -- and \emph{verification}, often linked with checks of requirements internal consistency within and between layers of abstraction; \emph{communication} reflects the notion that requirements are part of a human activity, through which all stakeholders agree on what is to be achieved; finally, the word \emph{abstraction} makes reference to the practice of organizing requirements into layers and of tracing the satisfaction relationship between those layers.

\subsection{Processes}
Without loss of generality, we can say that requirements engineering can be split into two main processes, \emph{requirements development} and \emph{requirements management}. Requirements development can be subdivided into elicitation, analysis, specification, and validation~(\citetitle{SWEBOK},~\citeyear{SWEBOK}). Figure~\ref{fig:requirements_engineering_disciplines} below shows the domain of requirements engineering split into requirements development, encompassing the activities just mentioned, and also requirements management.

\begin{figure}[h]
\includegraphics[width=0.75\textwidth]{RequirementsEngineeringDisciplines}
\centering
\caption[Requirements engineering disciplines]{Requirements engineering disciplines~\citep[p. 15]{Wiegers2013}}
\label{fig:requirements_engineering_disciplines}
\end{figure}

Regardless of the development life cycle followed -- be it pure waterfall, iterative, incremental, agile, or other -- these activities will be present, perhaps at different times in the project and to varying degrees of detail~\citep{Wiegers2013}. Following are the essential actions in each sub-discipline.

\emph{Requirements elicitation} encompasses all of the activities involved with discovering requirements, such as interviews, workshops, document analysis and others. It is a process through which those who acquire and those who supply a given system discover, review, articulate, understand, and document the requirements on the system and the life cycle processes~(\citefield{ieee_std_29148}{journaltitle}). It typically assumes either a usage-centric or a product-centric approach, although other strategies are also possible. The usage-centric strategy emphasizes understanding and exploring user goals to derive the necessary system functionality. The product-centric approach focuses on defining features that you expect will lead to marketplace or business success~\citep{Wiegers2013}.

The same standard defines \emph{requirements analysis} as a process that transforms stakeholder and requirement-driven views of desired services into technical views of products that could deliver those services. The main goal is to obtain a precise understanding of each requirement and representing sets of requirements in appropriate ways. This is done by distinguishing users' goals from functional requirements, determining quality expectations, business rules, suggested solutions, and other information~\citep{Wiegers2013}.

\emph{Requirements specification} involves representing and storing the collected knowledge and information in a persistent and well-organized fashion. The principal activity is translating the collected user needs into written requirements and, optionally visual models, suitable for comprehension, review and use by their intended audiences~\citep{Wiegers2013}.

\citefield{ieee_std_29148}{journaltitle} defines \emph{requirements validation} as a confirmation by examination that requirements (individually and as a set) define the right system as intended by the stakeholders. It confirms that information gathered will enable developers to build a solution that satisfies the business objectives. The central activities are reviewing the documented requirements to correct any problems before the development group accepts them; developing acceptance tests and criteria to confirm that a product based on the requirements would meet customer needs and achieve the business objectives~\citep{Wiegers2013}.

\citet{Wiegers2013} allude that, from a practical point of view, the goal of \emph{requirements development} is to accumulate a shared understanding of requirements that is good enough to allow construction of the next portion of the product, be that 1 or 100 percent of the entire product, to proceed at an acceptable level of risk. It is in line with what~\citefield{ieee_std_29148}{journaltitle} refers to as a \emph{baseline} set of requirements, a `specification or product that has been formally reviewed and agreed upon, that thereafter serves as the basis for further development, and that can be changed only through formal change control procedures'. The major risk is that, if not performed properly, excessive unplanned rework will be needed because of insufficient understanding of the requirements for the next chunk of work before starting design and construction~\citep{Wiegers2013}.

\citefield{ieee_std_29148}{journaltitle} identifies processes and activities within, that are named differently, but that are in essence similar to the ones just described. The principal processes identified are \emph{stakeholder requirements definition} and \emph{requirements analysis} or \emph{system requirements analysis}. These two processes result in a baseline set of requirements, with a nature similar to the mentioned before. The architectural design process includes allocation and decomposition of requirements that triggers the recursive application of the requirements processes, for the definition of system element requirements and the iterative application of the requirements analysis process for derived requirements.

There is a common misconception that requirements engineering is just a single phase that is carried out and completed at the outset of product development~\citep{Hull2011}. On the contrary, requirements developed at the outset are still in use at the final stages of development. Figure~\ref{fig:testsandreqs} shows different testing activities and their relationship with requirements specified at various levels of abstraction. It is clear that stakeholder requirements are tested as part of acceptance test, a late stage in any software development method, be it traditional or agile. In addition, each testing activity has a separate concern, with acceptance test focusing on validating the product; system test verifying the system; and integration and component testing verifying subsystem and components requirements, respectively.
\begin{figure}[h]
\includegraphics[width=0.75\textwidth]{RoleOfRequirementsInRelationToTesting}
\centering
\caption[Testing activities and requirements]{Testing activities and requirements~\citep{Hull2011}}
\label{fig:testsandreqs}
\end{figure}

If requirements are to play such a central role in systems development, they need to be maintained. Hence requirements engineering connects strongly with change management. Independently of where new or changed requirements come from, the impact of that change on quality, cost and schedule needs to be assessed. This assessment informs decisions to either accept or reject a change; negotiate the cost of change and organise and assign work to development teams~\citep{Hull2011}. The purpose of \emph{requirements management} is to anticipate and accommodate requirements changes, so as to minimize their disruptive impact on the project. Core requirements management activities include defining the requirements baseline; evaluating the impact of proposed requirements changes; establishing any relationships and dependencies between requirements and tracking requirements status and change activity throughout the project~\citep{Wiegers2013}.

The key concept that enables this kind of impact analysis is requirements tracing, primarily concerned with understanding how high-level requirements -- objectives, goals, aims, aspirations, expectations, needs -- are turned into low-level requirements. It is therefore primarily concerned with the relationships between layers of information. Requirements tracing allows measuring the impact of change, tracking progress against a set of requirements and assessing benefit against cost of implementation~\citep{Hull2011}.

\section{Agile Requirements Engineering}
\label{sec:agile_requirements}
Traditional software development methods, such as waterfall~\footnote{~\citet{royce1970managing} is known to have first described the waterfall process, even though he did not use that term}, advocate a simple top-down flow of requirements information (see figure~\ref{fig:waterfall}). In this model, software development occurs in an orderly series of sequential stages. Requirements are agreed to, a design is created, and code follows thereafter. Lastly, the software is tested to verify its conformance to its requirements and design, and deployed to its users upon successful verification~\citep{Leffingwell2011}.

\begin{figure}[h!]
\includegraphics[width=0.60\textwidth]{waterfall2}
\centering
\caption[Sequential stages in waterfall development]{Sequential stages in waterfall development~\citep{Leffingwell2011}}
\label{fig:waterfall}
\end{figure}

The past decade has seen a movement to more lightweight and increasingly agile methods. Software technology has moved from supporting business operations to becoming a critical component of business strategy~\citep{Highsmith:2000:ASD:323922}. The move towards agile methods was driven by the same causes that led manufacturers to transition from mass production to lean production techniques, namely a focus on quality, cost reduction and an increase in speed to market.

We will not detail an historical perspective of the evolution from predictive, waterfall-like methods to iterative and incremental processes (e.g RUP~\footnote{~see \citetitle{Kruchten2003},~\citet{Kruchten2003} for details}) to the more recent agile and lean development methods~\citep{Leffingwell2011,Larman2003}. Instead, we describe an agile requirements artefact model and corresponding agile practices and principles, that compose the agile requirements approach found in current agile methods. In addition, we introduce BDD and explain it in the context of \emph{Specification by Example}~\citep{Adzic201106} practices and principles.

\subsection{Agile practices and principles}
The agile manifesto~\footnote{~see http://www.agilemanifesto.org/ for details} declares that: 
\emph{We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value}

\begin{itemize}
\item \textbf{Individuals and interactions} over processes and tools;
\item \textbf{Working software} over comprehensive documentation;
\item \textbf{Customer collaboration} over contract negotiation;
\item \textbf{Responding to change} over following a plan.
\end{itemize}
\emph{That is, while there is value in the items on the right, we value the items on the left more.}

In each statement, the first part (in bold face) indicates a preference, whilst the other represents an item that, although relevant, is of lower priority. The signers of the manifesto chose their words carefully and the use of the word \emph{`uncovering'} and the expression \emph{`by doing it'}, place agile as a continuous incremental learning process carried out by practitioners in the software engineering field.

Agile development reverses the traditional approach of favouring processes and tools over people. In agile, the emphasis is much more on people collaboration and interaction than in following a plan or using a particular set of tools. Similarly, while comprehensive documentation is not a problem in itself, the emphasis should be in working software. Agile methods shift from strict contract negotiation to close collaboration between team members and customers, ensuring delivered software meets customer needs. Finally, agile realises that customer needs are not static and accepts changes to requirements, even if late in the project~\citep{Highsmith:2000:ASD:323922}. 

In agile development approaches we expect cycles and iteration among the business, user, and functional requirements~\citep{Wiegers2013} and where goals are defined for each iteration and are revisited once the iteration is completed~\citep{Inayat2015}. Often, it is impossible or unnecessary to fully specify functional requirements before commencing design and implementation. The essence of agile development is learning just enough about requirements to do thoughtful prioritization and release planning so that teams can begin delivering valuable software as quickly as possible~\citep{Wiegers2013}.

In response to a somehow fragmented knowledge about the solutions that agile brought to requirements engineering and the new challenges it has raised,~\citet{Qasaimeh2008} reflect on the differences of `traditional' and agile requirements engineering, the practices adopted by the latter and the solutions and challenges presented by adoption of agile requirements. The study compared different agile development methods, analysed their characteristics and classified them based on key requirements for a software development project. They analysed some of the most popular agile software methods such as Scrum~\footnote{~see \citetitle{Schwaber:2001:ASD:559553},~ \citet{Schwaber:2001:ASD:559553} for details}, Extreme Programming~(XP)~\footnote{~see \citetitle{Beck:1999:EPE:318762},~ \citet{Beck:1999:EPE:318762} for details}, Feature Driven Development~(FDD)~\footnote{~see \citetitle{Palmer:2001:PGF:600044}~\citet{Palmer:2001:PGF:600044} for details}, Adaptive Software Development (ASD)~\footnote{~see \citetitle{Highsmith:2000:ASD:323922},~ \citet{Highsmith:2000:ASD:323922} for details} and Crystal Methodologies~\footnote{~see \citetitle{CockburnCrystal2004} and~ \citet{CockburnCrystal2004} for details}. They concluded that \emph{customer involvement} is a key practice in all agile processes and all analysed methods consider customers an integral part of the development process. Some of the methods advocate the presence of the customer on-site to elicit, prioritize and verify requirements and also during acceptance testing, where most agile processes require tests to be written and executed by customers.

To reduce \emph{time to market}, most agile processes favour early delivery of software so that customers can use the software and provide feedback early on, improving defect rates and the customers understanding of the expected software features. Agile processes have the ability to quickly \emph{respond to change}, with some processes relying on daily meetings with users, and promoting direct user interaction in determining changes to requirements and deciding what and when changes to requirements are going to be implemented. An informal approach to \emph{documentation} is favoured and agile processes advocate face to face communication and presence of on-site user representatives.

The practices just described are not specific to an agile development method, but rather have evolved from multiple uses and empirical studies of commonality across methods.

All agile processes place focus on \emph{verification and validation} of requirements, using testing techniques such as unit, integration and regression testing. Other quality review techniques are also used such as design and code inspections, retrospectives and code quality reviews. They also foster team communication and collaborative work by doing daily `stand ups' -- started in Scrum and now widely accepted as common practice, where all team members stand up around a circle, hence the name, for about 10 to 15 minutes and discuss what they have been doing since the last time they met and any issues or blockers they may be faced with -- and use of code standards for facilitating exchange of information among team members.

\subsection{Agile requirements artefact model}
Nowadays, a significant number of organizations have made the transition to agile and that has brought to light common patterns for agile software processes. ~\citet{Leffingwell2011} introduces the idea of the \emph{Agile Enterprise Big Picture} (see figure~\ref{fig:scaled_agile_framework}) with the goal of sharing a language for discussion, a set of abstractions, and a visual model that describes agile software development and delivery process mechanisms, the teams and organizational units, and some of the roles key individuals play in the new agile paradigm. The vocabulary introduced is a method-independent set of constructs widely used in the industry and generally accepted in current agile development practices.

\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{ScaledAgileFrameworkbw}
\centering
\caption[Agile enterprise]{Agile development levels: \emph{Team}, \emph{Program} and \emph{Portfolio}~\citep{Leffingwell2011}}
\label{fig:scaled_agile_framework}
\end{figure}

\citeauthor{Leffingwell2011} describes agile at scale at different levels of detail and with increasing abstraction, from \emph{Team} to \emph{Program} and finally \emph{Portfolio}. \\

At the \emph{Team} level
\begin{displaycquote}{Leffingwell2011}
... agile teams define, build, and test user stories in a series of iterations and releases. In the smallest enterprise, there may be only a few such teams. In larger enterprises, groups, or pods, of agile teams work together to support building up larger functionality into complete products, features, architectural components, subsystems, and so on. The responsibility for managing the backlog of user stories belongs to the team's product owner. 
\end{displaycquote}

At the \emph{Program} level
\begin{displaycquote}{Leffingwell2011}
...the development of larger-scale systems functionality is accomplished via multiple teams in a synchronized standard cadence of time-boxed iterations and milestones that are date and quality fixed, but scope is variable, producing releases or potentially shippable increments (PSI) at frequent, typically fixed, 60 to 120 day time boundaries.
\end{displaycquote}

At the \emph{Portfolio} level
\begin{displaycquote}{Leffingwell2011}
... a mix of themes are used to drive the investment priorities for the enterprise. That construct assures that the work being performed is the work necessary for the enterprise to deliver on its chosen business strategy. Investment themes drive the portfolio vision, which is expressed as a series of larger, epic-scale initiatives, which will be allocated to various release trains over time.
\end{displaycquote}

In the context of this thesis, \emph{Team} and \emph{Program} levels are the most relevant. In addition, together with an agile requirements artefact meta-model (see figure~\ref{fig:metamodel_partial}), we are in possession of an unambiguous and coherent language for doing research in agile requirements engineering. We will delve less into the organisational and team composition aspects of the model, but instead focus on the elements introduced by the meta-model.

\begin{figure}[h]
\includegraphics[width=0.65\textwidth]{metamodel_partial2}
\centering
\caption{Agile requirements meta-model for the \emph{Team}}
\label{fig:metamodel_partial}
\end{figure}

The meta-model defines the concept of a \emph{Backlog Item} -- an abstract entity representing something that needs to be done, either a user story or another work item -- and a \emph{Backlog}, a repository of all the work items the team has identified. This backlog is the one and only definitive source of work for the team. A \emph{Story} is the rough equivalent of a software requirement in agile and, at the \emph{Team} level, we distinguish two types: a \emph{User Story} -- used to define the system behaviour and determine value for the user -- and \emph{other work items} such as defects, documentation, support and maintenance activities, infra-structure work and so on. \citet{Leffingwell2011} defines \emph{Story} as \emph{`a work item contained in the team's backlog'} and \emph{User Story} as \emph{`a brief statement of intent that describes something the system needs to do for the user'}.

\emph{Tasks} are used to breakdown a \emph{Story} in work activities required to its implementation. Note that \emph{Tasks} can exist on their own and without an associated \emph{Story}, if the work activity is considered independent and can stand alone. Also, a \emph{Story} requires one or more tasks for its implementation and is only complete when it passes one or more \emph{acceptance tests}. A \emph{Story} could also be subject to \emph{unit tests} to confirm that the lowest-level module of an application or module of an application works as intended.

\begin{figure}[!h]
\includegraphics[width=0.50\textwidth]{metamodel_features2}
\centering
\caption{Agile requirements meta-model (\emph{Features})}
\label{fig:metamodel_features}
\end{figure}

At \emph{Program} level, the backlog contains a prioritized set of \emph{features} intended to deliver benefits to the users. \citet{Leffingwell2011} defines \emph{Features} as \emph{`services provided by the system that fulfil stakeholder needs'}. \emph{Features} are a kind of backlog item as can be seen in figure~\ref{fig:metamodel_features}. \emph{Features} are at a higher level of abstraction than \emph{Stories} and sit between needs of users and software requirements, expressed in agile as \emph{Stories}. A given \emph{Feature} is realised by one or more \emph{Stories}.

\begin{figure}[h]
\includegraphics[width=0.50\textwidth]{metamodel_features_tests}
\centering
\caption{Agile requirements meta-model (\emph{Features} and \emph{Acceptance Tests})}
\label{fig:metamodel_features_tests}
\end{figure}

Similar to \emph{Stories}, \emph{Features} also require acceptance tests to ensure that all stories that realise it are complete. Note that a \emph{Feature acceptance test} is not a composition of \emph{Story acceptance tests}, as they should focus on other types of tests such as performance, `what-if' scenarios, etc. 

\emph{Features} and \emph{Stories} are used to specify the functionality of a system but we should not ignore non-functional requirements. In the model in figure~\ref{fig:metamodel_nfrs}, we see first that some backlog items may be constrained by non-functional requirements, and some may not. We also see that non-functional requirements may not apply to backlog items, meaning that they stand independently and apply to the system as a whole~\citep{Leffingwell2011}.

\begin{figure}[h]
\includegraphics[width=0.55\textwidth]{metamodel_nfrs}
\centering
\caption{Agile requirements meta-model (\emph{Non-functional requirements})}
\label{fig:metamodel_nfrs}
\end{figure}

It is important to note that a non-functional requirement constrains a \emph{Backlog item} which can be either \emph{Features} or \emph{Stories}. This is important from a practical perspective as it is not uncommon to have agile teams starting with \emph{Features} to organise their \emph{backlog}. This is also the case in some agile approaches such as the one described in the next section.

\subsection{Behaviour driven development~(BDD)}
\label{ch:Background:sec:bdd}
\citet{Hull2011} advocates the use of modelling techniques as a mechanism of fostering understanding and communication of ideas associated with system development. Good models are those that are easily communicated. They need to be used for communication within a development team, and also to an organisation as a whole including the stakeholders. The uses of a model can be diverse and cover a wide spectrum. It might be to model the activities of an entire organisation or to model a specific functional requirement of a system. It is this latter use that receives the attention of Behaviour Driven Development which is, in its essence, an approach to derive the functionality of a system or component from business goals using concrete examples~(see figure~\ref{fig:bdd_from_goals_to_specs}).

In the foreword to \citet{Smart201410}, Dan North the creator of BDD states that `... (BDD) was a response to a triple conundrum: programmers didn't want to write tests; testers didn't want programmers writing tests; and business stakeholders didn't see any value in anything that wasn't production code'.

BDD applies at all levels of software development, from high-level requirements discovery and specification to detailed low-level coding, whilst promoting the discovery of requirements and automation of high-level acceptance criteria, build and verification of the design and implementation, and production of accurate and up-to-date technical and functional documentation~\citep{Smart201410}.

\begin{figure}[h]
\includegraphics[width=0.75\textwidth]{BDD}
\centering
\caption[From business goals to executable specifications]{BDD: From business goals to executable specifications~\citep{Smart201410}}
\label{fig:bdd_from_goals_to_specs}
\end{figure}

BDD helps teams focus their efforts on identifying, understanding, and building valuable features that matter to businesses, and it makes sure that these features are well designed and well implemented~\citep{Smart201410}. BDD practitioners use conversations around concrete examples of system behaviour to help understand how features will provide value to the business. Furthermore, it encourages business analysts, software developers, and testers to collaborate more closely by enabling them to express requirements in a more testable way, in a form that both the development team and business stakeholders can easily understand. Tools exist that can help turn these requirements into automated tests that help guide the developer, verify the feature, and document what the application does~\citep{Smart201410,wynne2012cucumber}. Figure~\ref{fig:bdd_from_goals_to_specs} depicts the typical flow of information in BDD, from business goals to features, followed by identification of concrete examples, all part of a specification that gets tested and verified against initial business goals stated.

\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{communication_in_bdd}
\centering
\caption[Improved communication in BDD]{Improved communication in BDD~\citep{Smart201410}}
\label{fig:communication_in_bdd}
\end{figure}

Some authors and practitioners do not consider BDD a software development methodology in its own right, but as a set of methods and techniques grouped under the same label, which incorporates, builds on, and enhances ideas from many agile and iterative methodologies~\citep{Smart201410}.

It is important to note that BDD was developed as a mechanism for fostering collaboration, improving communication and requirements discovery through examples. In traditional development methods, requirements follow a sequential set of activities where typically a business owner informs an analyst of his needs and goals, who in turn will write a requirements document that a developer translates into software. Simultaneously, or upon completion of development, a tester translates the same requirements document into test cases which, if executed with success, lead to user and technical documentation being produced and the software being deployed to end-users. In BDD the focus is on collaboration, with all interested parties sharing a structured specification that is used to simultaneously, specify features to be implemented and tests to be executed.

BDD can also be seen as an instance of \emph{Specification by Example}~\citep{Adzic201106} as they both share a common set of principles and practices. \emph{Specification by example} introduces a consistent and coherent language for patterns, ideas and artefacts used for teams who derive \emph{executable specifications} and \emph{living documentation} from \emph{business goals}. The practices of \emph{Specification by Example} do not form a fully fledged software development methodology but rather supplement other methodologies -- both iterative and flow based -- to provide rigour in specifications and testing, enhance communication between various stakeholders and members of the software development team~\citep{Adzic201106}.

\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{SpecificationbyExample}
\centering
\caption[Specification by Example]{Process patterns of \emph{Specification by Example}~\citep{Adzic201106}}
\label{fig:specification_by_example}
\end{figure}

Instead of relying on users to provide requirements, teams \emph{derive scope from goals}, taking customer's business goals and defining the scope in terms of the set of features that achieve those goals. This is done collaboratively with business users and team members, to improve communication and reduce unnecessary rework. \emph{Specifying collaboratively} they are able to harness the knowledge and experience of all team members. It also creates a collective ownership of specifications, making everyone more engaged in the delivery process~\citep{Adzic201106}.

Teams \emph{illustrate specifications using examples}. The team works with business users to identify key examples describing expected functionality, flushing out functional gaps and inconsistencies and ensuring that everyone involved has a shared understanding of what needs to be delivered, avoiding rework that results from misinterpretation and translation~\citep{Adzic201106}.

\emph{Key examples} must be concise to be useful. By \emph{refining the specification}, successful teams remove extraneous information and create a concrete and precise context for development and testing. They define the target with the right amount of detail to implement and verify it. They identify what the software is supposed to do, not how it does it~\citep{Adzic201106}.

Once a team agrees on \emph{specifications with examples} and refines them, the team can use them as a target for implementation and a means to validate the product. To get the most out of key examples, successful teams automate validation without changing the information. As they\emph{ automate validation without changing specifications}, the key examples are always comprehensible and accessible to all team members. An automated \emph{Specification with examples} that is comprehensible and accessible to all team members becomes an \emph{executable specification}. We can use it as a target for development and easily check if the system does what was agreed on, and we can use that same document to get clarification from business users~\citep{Adzic201106}.

\emph{Validating frequently} executable specifications against the system ensures we can discover any differences between the system and the specifications and keep both synchronised in face of changes to requirements or implementation. Not only do teams validate frequently, they also ensure that specifications are actual, current and consistent, effectively turning them into \emph{living documentation}.

In BDD, \emph{executable specifications} are expressed using \emph{Gherkin}~\citep{wynne2012cucumber}, a domain specific language used to specify desired features of a system or application (see feature~\ref{lst:feature_example} for an example of a specification in Gherkin). 

\begin{featurelist}{Example of a feature file in Gherkin~\citep{wynne2012cucumber}}{lst:feature_example}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}
Feature: Feedback when entering invalid credit card details

  In user testing we've seen a lot of people who made mistakes
  entering their credit card. We need to be as helpful as possible
  here to avoid losing users at this crucial stage of the
  transaction.

  Background:
    Given I have chosen some items to buy
    And I am about to enter my credit card details

  Scenario: Credit card number too short
    When I enter a card number that's only 15 digits long
    And all the other details are correct
    And I submit the form
    Then the form should be redisplayed
    And I should see a message advising me of the correct number of digits

  Scenario: Expiry date invalid
    When I enter a card expiry date that's in the past
    And all the other details are correct
    And I submit the form
    Then the form should be redisplayed
    And I should see a message telling me the expiry date must be wrong
\end{minted}
\end{featurecode}
\end{featurelist}

\emph{Gherkin} specifications are  defined from plain-language text files called \emph{feature files}, containing scenarios to implement and test, representing concrete examples of the features being specified. Each scenario is a list of steps for a BDD tool such as Cucumber to work through~\citep{wynne2012cucumber}. These tools parse feature files turning each scenario step into source code, typically a method call in one of the tool's supported languages. 
Feature~\ref{lst:feature_example} displays a feature file, specified in \emph{Gherkin}, for a credit card application containing two scenarios with concrete examples of credit card validation rules. In Gherkin, we use the \emph{Feature} keyword to name (in the text after \emph{Feature} keyword, excluding colon character) and describe (all remaining text until the next keyword) a feature. Gherkin uses the \emph{Background} keyword to specify a set of steps that are common to every scenario and within each scenario \emph{Given} is used to set up the context where the scenario happens, \emph{When} to interact with the system somehow and \emph{Then} to check that the outcome of that interaction was what we expected. \emph{And} and \emph{But} keywords are used to make specifications more readable and take the same role as the keyword in the previous line.

\subsection{Summary}

In this chapter we have provided definitions of requirements and presented them within the context of requirements engineering. We followed with an analysis of core activities of requirements engineering and described how they manifest in the context of agile development methods. Finally, we introduced BDD in context with \emph{Specification by Example} and gave an example a feature specification in Gherkin.

It is important to state that in BDD, and other agile approaches in general, handling of non-functional requirements is ill defined. Customers or users talking about what they want the system to do normally do not think about resources, maintainability, portability or performance~\citep{Paetsch:2003tl}. In the next chapter we will explore further the notion of non-functional requirements, present some well known classification schemes, and methods used for their elicitation and analysis with a focus on goal-oriented approaches and GRL~\citep{Amyot2010}, in particular.

\chapter{On non-functional requirements}
\label{ch:nfr_research}
In the previous chapter we have followed a generic approach to requirements engineering, without focusing on any particular requirement type. In this chapter, we take a different view and focus on the concept of \nfrs in requirements engineering.

It is generally accepted that a system's utility is determined by both its functional and non-functional characteristics, such as usability, flexibility and performance~\citep{Chung:2009vg}.

The perception of quality is determined by these two characteristic sets, and therefore, they must be taken into consideration in the development of software systems. However, most of the attention in software engineering in the past has been centred on notations and techniques for defining and providing the functions of a software system~\citep{Chung:2009vg}. Additionally, in the occasions where non-functional characteristics are taken into consideration, they are treated only as technical issues related mostly to the detailed design or testing of an implemented system~\citep{Chung:2009vg}.

\citet{Chung:2009vg} noted that real-world problems are more non-functionally oriented than they are functionally oriented, e.g., poor productivity, slow processing, high cost, low quality and unhappy customers. Rather than worry about precisely how to refer to these information types, it is more pertinent to ensure they are part of requirements elicitation and analysis activities. A product can be delivered with the desired functionality but that users hate because it doesn't match their (often unstated) quality expectations~\citep{Wiegers2013}.

In the remainder of this chapter, we will highlight issues with current definitions of non-functional requirements. We will also list relevant classification and representation schemes. Finally, we will introduce goal-oriented approaches to handling non-functional requirements, with a focus on goal-oriented requirements language (GRL).

\section{Definition}
For many years, the requirements for a software product have been classified broadly as either functional or non-functional. The functional requirements are evident: they describe the observable behaviour of the system under various conditions. However, many people dislike the term `non-functional'~\citep{Wiegers2013}. 

These `other-than-functional' requirements, could refer to \emph{how} well a system performs its functions, rather than to \emph{what} those functions may be. They could describe important characteristics or properties of a system, such as availability or performance. Likewise, they could be considered as \emph{quality attributes}~(\citefield{ieee_std_1061}{journaltitle}), but that view ignores other aspects such as design and implementation constraints or business rules, which we could also view as non-functional characteristics~\citep{Wiegers2013}.

We now provide three selected definitions, not because of their special correctness or attractiveness, but because they are amongst the more popular ones and support the argument that present definitions are inconsistent, ambiguous and confusing at times~\citep{Glinz:2007ehba}.

\citet{Wiegers2013} defines non-functional requirements as
\begin{displaycquote}{Wiegers2013}
... descriptions of a \emph{property} or \emph{characteristic} that a software system must exhibit or a \emph{constraint} that it must respect, other than an observable system behaviour
\end{displaycquote}

while \citet{Jacobson:1999:USD:309683} defines them as
\begin{displaycquote}{Jacobson:1999:USD:309683}
.. a requirement that specifies system properties, such as environmental and \emph{implementation constraints}, performance, platform dependencies, maintainability, extensibility, and reliability. A requirement that specifies \emph{physical constraints} on a functional requirement.
\end{displaycquote}

and \citet{Sommerville:1998:REP:552009} as requirements which are
\begin{displaycquote}{Sommerville:1998:REP:552009}
... not specifically concerned with the functionality of a system, instead specifying restrictions on the product being developed and the development process, and \emph{external constraints} the product must meet.
\end{displaycquote}

\citet{Glinz:2007ehba} identifies terminological, but also major conceptual issues with current definitions of non-functional requirements. Most definitions use the terms \emph{property} or \emph{characteristic}, \emph{attribute}, \emph{quality} or \emph{constraint} differently, and the meaning of those terms is not always clear. For example, \emph{property} and \emph{characteristic} denote something that the system must have, but that is equally a criteria for inclusion in functional requirements definitions. Also, every non-functional requirement (or functional, for this matter) can be regarded as a quality of a system or as a constraint, because it restricts the space of potential solutions to those that meet this requirement~\citep{Glinz:2007ehba}. In addition, there are references to implementation, physical and external constraints and not only there is a lack of clear guidance as to what they intend to restrict, also, these restrictions or constraints are known by different terms in other definitions, such as \emph{`interface requirements'} or \emph{`design constraints'}. Finally, \emph{performance} is treated as a quality or attribute is most definitions, but it deserves a category of its own in some quality models~(\citefield{ieee_std_29148}{journaltitle}).

\section{Classification and representation schemes}

The definitions we have just alluded to, refer to concepts that are considered to be part of non-functional requirements. However, there are more detailed classification schemes that are worth our attention.

\citet{Roman:1985} provides one such classification scheme based on the notion of constraints and types of constraints. \emph{Interface} constraints, define the way components of a system or application and its environment, interact. \emph{Performance} constraints, cover a broad range of issues dealing with time/space bounds, reliability, security, and survivability. \emph{Operating} constraints, include physical (e.g., size, weight, power, etc.), personnel availability, skill level considerations, accessibility for maintenance, environmental conditions (e.g., temperature, radiation, etc.), and spatial distribution of components. \emph{Life-cycle} constraints, fall into two broad categories: those that pertain to qualities of the design, such as maintainability or portability, and those that limit the development, maintenance, and enhancement process. \emph{Economic} constraints, represent considerations relating to immediate and long term costs. Finally, \emph{political} constraints deal with policy and legal issues. This view of non-functional requirements as constraints of components of a system or application will be explored further in Chapter~\ref{ch:Extendingbdd}.

Another classification scheme is introduced by~\citefield{ieee_std_9126One}{journaltitle} and its interpretation of software quality. Software product quality can be evaluated by measuring internal attributes (typically static measures of intermediate products), or by measuring external attributes (typically by measuring the behaviour of the code when executed), or by measuring quality in use attributes. The objective is for the product to have the required effect in a particular context of use.

This standard defined a quality model for external and internal quality. It categorises software quality attributes into six characteristics (functionality, reliability, usability, efficiency, maintainability and portability), which are further subdivided into sub-characteristics.

\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{QualityInLifecycle}
\centering
\caption[Software product quality model]{Software product quality model ( \citefield{ieee_std_9126One}{journaltitle})}
\label{fig:QualityInLifecycle}
\end{figure}

Interestingly, several issues have been identified with~\citefield{ieee_std_9126One}{journaltitle}, such as terminology inconsistencies with other ISO standards; ambiguities in the way it is structured in terms of characteristics and sub-characteristics; incomplete set of characteristics and sub-characteristics, etc.~\citep{Al-Qutaish}.

\begin{figure}[h]
\includegraphics[width=0.65\textwidth]{iso25010}
\centering
\caption[ISO 25010 quality model]{ISO 25010 quality model~(\citefield{ieee_std_25010}{journaltitle})}
\label{fig:iso25010}
\end{figure}

This has lead to a revised standard that extends this quality model with eight product quality characteristics and 31 sub-characteristics~(\citefield{ieee_std_25010}{journaltitle}) (see figure~\ref{fig:iso25010}).

There have also been attempts to automate the classification of non-functional requirements. One of such approaches, detects and classifies stakeholders quality concerns across requirements specifications containing scattered and non-categorized requirements, and also across free-form documents such as meeting minutes or notes~\citep{Cleland-Huang:2007}. A similar approach proposes a semi-supervised text categorization for the automatic identification and classification of non-functional requirements~\citep{Casamayor:2010}.

According to \citet{Glinz:2007ehba}, the categorization and sub-classification of non-functional requirements in current classification schemes reflect rather divergent concepts. For instance, whilst~\citet{Roman:1985} presents a classification scheme based on the notion of constraints, \citet{adams2015non} devises another scheme around concerns. Glinz had previously found more classification problems due to mixing three concepts that should better be separated. These are the concepts of \emph{kind} (should a given requirement be regarded as a function, a quality, a constraint, etc.), \emph{representation} and \emph{satisfaction} (hard vs. soft requirements)~\citep{Glinz:2005unba}.

A software practitioner should be aware of the well known classification schemes and their limitations, such as the terminological and categorical inconsistencies mentioned above. More than be concerned with choosing the right scheme, he or she should know what each attribute or quality characteristic means, such as performance, so that the correct intent can be communicated between users, developers and testers who, ultimately, will implement and verify appropriate features in the product or application~\citep{Chung:2009vg}.

According to~\citet{Matoussi:2008wr}, there are three extreme ways of specifying software requirements: complete formal specifications, informal specifications and hybrid or semi-formal approaches. We proceed by sampling from the literature several approaches belonging to the above mentioned categories.

\emph{No-Fun}~\citep{Franch1998} belongs to the formal category of representation schemes. \emph{NoFun} (acronym for `NOn-FUNctional'), is a formal language for the description of software quality consisting of a hierarchy of software quality characteristics and attributes formulated as abstract and concrete quality models; component quality descriptions through assignment of values to component quality basic attributes, and finally, quality requirements stated over components, both context-free (universal quality properties) and context-dependent (quality properties for a given framework software domain, company, project, etc.)~\citep{Franch1998}. In another paper~\citep{NoFunWithISO}, the framework was applied to the set of quality attributes refinements that are part of~\citet{ieee_std_9126One}.

\citet{Chung:2009vg} mention that an informal and common way to represent non-functional requirements is by means of requirements sentences, which are commonly listed separately under different sections of a requirements document and refers to~\citefield{ieee_830}{journaltitle}, superseded by~\citefield{ieee_std_29148}{journaltitle}, as an example.

There are also informal but structured approaches around requirements sentences, such as the \emph{Volere} requirements process~\citep{Robertson:1999}, in which each requirement is comprised of an identification number, NFR type, use case related to it, description, rationale, originator, fit criterion, customer satisfaction, customer dissatisfaction, priority, conflicts, supporting material, and history~\citep{Chung:2009vg}.

In spite of all of the above ways by which non-functional requirements have been classified and represented, goal-oriented approaches were the first to treat \nfrs in more depth, dealing with their representation but also conflict detection amongst multiple non-functional requirements. 

\section{Goal-oriented approaches}
The use of goals in requirements engineering has received increasing attention over the past few years. Such recognition has led to a whole stream of research on goal modelling, goal specification, and goal-based reasoning for multiple purposes, such as requirements elaboration, verification or conflict management, and under multiple forms, from informal to qualitative to formal~\citep{Lamsweerde:2001wpba}.

A goal captures, at different levels of abstraction, the various objectives the system under consideration should achieve~\citep{Lamsweerde:2001wpba}. Goals also cover functional concerns associated with the services to be provided, and non-functional ones, associated with quality of service, such as safety, security, accuracy, performance, and so forth.

The \emph{NFR Framework}~\citep{Chung2000} has probably been the first requirements model to address the lack of a proper treatment of quality characteristics by addressing both functional and non-functional requirements as a whole, and at a higher level of abstraction for both the problem and the solution~\citep{Chung:2009vg}.

In the \emph{NFR Framework}, non-functional requirements are treated as softgoals, i.e., goals that need to be addressed not absolutely but in a good enough sense. Reflecting the sense of `good enough', the \emph{NFR Framework} introduces the notion of satisficing, and, with this notion, a softgoal is said to `satisfice' (instead of satisfy) another softgoal. Softgoals are related through relationships which represent the influence or interdependency of one softgoal on another. A qualitative analysis method is included in the framework for deciding the status of softgoals, given that other, related softgoals are satisficed or have been found to be unsatisficable~\citep{Chung2000}.

\begin{figure}[h]
\includegraphics[width=0.75\textwidth]{SIGLegend}
\centering
\caption[Catalogue of visual elements in NFR Framework]{Catalogue of visual elements in NFR Framework~\footnotemark}
\label{fig:sig_legend}
\end{figure}
\footnotetext{~sourced from  http://www.utdallas.edu/~supakkul/NFR-modeling/label-evaluation}

Figure~\ref{fig:sig_legend} shows in graphical form the most important concepts of the \emph{NFR Framework}. Softgoals, which are `soft' in nature, are shown as clouds and can be decomposed into specific softgoals though decomposition links. We say that softgoals are refined downwards into subgoals, and subgoals contribute upwards to parent softgoals. There are two main types of decompositions, \emph{AND} and \emph{OR}, with the former used when several subgoals are needed together to meet a higher softgoal, and the latter when one subgoal alone is sufficient. 

When the non-functional requirements have been sufficiently refined, the next step is to identify \emph{operationalisations} (tick dark clouds), which are possible development techniques or specific solutions for achieving these non-functional requirements. In the \emph{NFR Framework}, each softgoal or contribution is associated with a \emph{label}, indicating the degree to which it is satisficed or denied.

The \emph{NFR Framework} offers several different types of contributions whereby a softgoal satisfices, or denies, another softgoal -- \emph{MAKE}, \emph{HELP}, \emph{HURT} and \emph{BREAK} are the prominent ones. While \emph{MAKE} and \emph{BREAK} respectively reflect our level of confidence in one softgoal fully satisficing or denying another, \emph{HELP} and \emph{HURT} respectively reflect our level of confidence in one softgoal partially satisficing or denying another~\citep{Chung:2009vg}. 

The NFR Framework uses non-functional requirements such as security, accuracy, performance and cost to drive the overall design process. The framework offers a structure for representing and recording the design and reasoning process in graphs, called softgoal interdependency graph (SIG)~\citep{Chung2000}. 

Main requirements are shown as \emph{softgoals} at the top of a graph. Softgoals are connected by \emph{interdependency links}, which are shown as lines, often with arrowheads. Softgoals have associated \emph{labels} (values representing the degree to which a softgoal is achieved) which are used to support the reasoning process during design~\citep{Chung2000}. 

Figure~\ref{fig:account_nfrs} shows a SIG for a hypothetical credit card application where security of account information and good performance in the storing and updating of that information have been elicited as non-functional requirements to attain.

\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{AccountNFRs2}
\centering
\caption[Example of a Softgoal Interdependency Graph]{Example of a Softgoal Interdependency Graph (SIG)~\footnotemark}
\label{fig:account_nfrs}
\end{figure}
\footnotetext{~sourced from  http://www.utdallas.edu/~supakkul/NFRs-catalog/}

These two non-functional requirements, softgoals in the \emph{NFR Framework} terminology, are represented as clouds at the top of the figure. Softgoals have a type (in this case, security and performance) and a topic, which refers to an entity from the domain or subject matter, in this case bank accounts. In the figure, the secure accounts softgoal is decomposed into sub-softgoals integrity, confidentiality and availability. In this case, the developer or designer has taken the view that authorizing access to account information would help attain confidentiality of accounts softgoal. This authorization access is then refined into an \emph{OR} decomposition of operationalisations, namely `Use pin', `Compare signature' or `Require other ID'.

Faced with those options, a decision is made to compare signatures by labelling the `compare signature' operationalisation as satisficed, which in turn will do the same to `Authenticate user access'.

The \emph{NFR Framework} rationalizes the development process by providing techniques for justifying design decisions made. These design decisions may positively or negatively affect one or more non-functional requirements, establishing interdependencies that allow inferring the degree to which those non-functional requirements are satisficed or denied~\citep{Chung2000}.

Handling non-functional requirements is complex, as it is difficult to define a non-functional term completely unambiguously and hard to explore a complete list of possible solutions and choose the best, or optimal solution~\citep{Chung:2009vg}. Therefore, the \emph{NFR Framework} takes a more lightweight and qualitative approach towards non-functional requirements, taking a view that softgoals are idealizations and, as such, without all its defining properties necessarily established.

\citet{Horkoff2012} suggests that models focusing on stakeholder goals are particularly suitable for elicitation and analysis in early requirements engineering, as they can show the underlying motivations for systems, capture non-functional success criteria, and show the effects of high-level design alternatives on the attainment of goals. We call this type of model, including agents with interdependent goals, agent-goal models, of which \emph{i*} and GRL are some of the most prominent examples.

The \emph{i*} framework incorporates concepts from the \emph{NFR framework}, including softgoals, \emph{AND/OR} decompositions, and contribution links, as well as (hard) goals, resources, and dependencies between actors (agents)~\citep{Horkoff2013}. \emph{i*} consists of two main modelling components. The \emph{Strategic Dependency (SD)} model is used to describe the dependency relationships among various actors in an organizational context. The \emph{Strategic Rationale (SR)} model is used to describe stakeholder interests and concerns, and how they might be addressed by various configurations of systems and environments~\citep{Yu1997}.

\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{istar_example}
\centering
\caption[Example of an \emph{i*} Strategic Dependency (SD) model]{Example of an \emph{i*} Strategic Dependency (SD) model~\citep{Roy:2007wyba}}
\label{fig:istar_example}
\end{figure}

Figure~\ref{fig:istar_example} shows a simple SD model with two actors represented by circles, a Customer and an Electronic Payment System, and their inter-dependencies. In the example, Payment represents a resource to be provided by the Customer, Secure Payment is a softgoal to be achieved by the System, and Keep Password Secret is a goal to be achieved by the Customer~\citep{Roy:2007wyba}.

The central concept in \emph{i*} is that of the intentional actor. Organizational actors are viewed as having intentional properties such as goals, beliefs, abilities, and commitments. Actors depend on each other for goals to be achieved, tasks to be performed, and resources to be furnished. By depending on others, an actor may be able to achieve goals that are difficult or imp 	ossible to achieve on its own~\citep{Yu1997}.

The concepts of \emph{actors} and \emph{intentional elements} in \emph{i*} have influenced other goal-oriented languages, and in particular GRL, a visual modelling notation for intentions, business goals, and non-functional requirements of many stakeholders, for alternatives that have to be considered, for decisions that were made, and for rationales that helped make these decisions~\citep{amyot2011user}. We describe GRL in depth in the next section.

\section{Goal-oriented Requirements Language~(GRL)}
\label{sec:gore}
The Goal-oriented Requirements Language (GRL)~\citep{Amyot2010} inherits the concept of softgoal from the \emph{NFR Framework}, and adopts non-functional characteristics and related attributes as first class modelling concepts~\citep{Chung:2009vg}. GRL captures business or system goals, alternative means of achieving goals (either objectively or subjectively), and rational for contributions and decisions~\citep{Amyot2003}. The language was developed with the following capability targets~\citep{Amyot2003}:

\begin{itemize}
\item to enable reasoning about feature interactions and trade-offs early in the design process;
\item to support the specification, analysis and management of goals and non-functional requirements;
\item to model the relationship between goals and system requirements;
\item to capture reusable analysis and design knowledge about non-functional requirements.
\end{itemize}

GRL is part of User Requirements Notation (URN)~(\citefield{ituZ151}{journaltitle}), an ITU-T approved standard, with two complementary notations: GRL for modelling actors and their intentions, goals and non-functional requirements, and Use Case Maps (UCM) notation for describing scenarios and architectures~\citep{Amyot2003}.~\citefield{ituZ151}{journaltitle} focuses on the definition of an abstract syntax, a concrete graphical syntax, and an interchange format for URN. In this section we will only cover what pertains to GRL, as UCM is out of scope. 

GRL is a visual modelling notation for intentions, business goals, and non-functional requirements of stakeholders, for alternatives that have to be considered, decisions that were made, and rationale that helped make these decisions~\citep{amyot2011user}.

There are four main categories of concepts in GRL: \emph{actors}, \emph{intentional elements}, \emph{indicators} and \emph{links}. Figure~\ref{fig:grl_visualsyntax} shows a summary of the graphical notation in GRL

\begin{figure}[h]
\includegraphics[width=0.75\textwidth]{grl_visualsyntax}
\centering
\caption[Summary of the GRL graphical notation]{Summary of the GRL graphical notation~\citep{Roy:2007wyba}}
\label{fig:grl_visualsyntax}
\end{figure}

The intentional elements in GRL are \emph{goals}, \emph{softgoals}, \emph{tasks}, \emph{resources} and \emph{beliefs}. \emph{Intentional} elements are used to present the different alternative behavioural (dynamic) and structural (static) aspects of the system requirements and concentrate on the rational for choosing a particular alternative over the others~\citep{Saleh2004}.

\emph{Actors} are holders of intentions; they are the active entities in the system or its environment (e.g., stakeholders or other systems) who want goals to be achieved, tasks to be performed, resources to be available and softgoals to be satisfied~(\citefield{ituZ151}{journaltitle}). \emph{Indicators} make real-world measurements available for reasoning in the goal model, allowing for a more accurate assessment of the satisfaction of actors~(\citefield{ituZ151}{journaltitle}). 

\emph{Softgoals} differentiate themselves from \emph{goals} in that there is no clear, objective measure of satisfaction for a softgoal whereas a goal is quantifiable, often in a binary way. Softgoals are often more related to non-functional requirements, whereas goals are more related to functional requirements~\citep{amyot2011user}.

\emph{Links} are used to connect isolated elements in the requirement model. Different types of links depict different structural and intentional relationships (including \emph{decompositions}, \emph{contributions} and \emph{dependencies})~(\citefield{ituZ151}{journaltitle}).

GRL supports the analysis of strategies, which help reach the most appropriate trade-offs among (often conflicting) goals of stakeholders. A \emph{strategy} consists of a set of intentional elements and indicators that are given initial satisfaction values~(\citefield{ituZ151}{journaltitle}). It uses qualitative labels associated with lower-level intentional elements to measure the satisfaction level of higher-level elements. The qualitative satisfaction labels associated with intentional elements go from \emph{SATISFICED} to \emph{DENIED}~\citep{Roy:2007wyba}. These satisfaction values are then propagated to the other intentional elements through their links, enabling a global assessment of the strategy being studied as well as the global satisfaction of the actors involved~(\citefield{ituZ151}{journaltitle}).

The GRL notation supports belief elements, which provide justifications of the assessments in the model. Beliefs keep track of the rationales in the graphical models~\citep{Roy:2007wyba}.

The URN standard describes the syntax and semantics of the language using an abstract syntax (partially shown in figure~\ref{fig:grl_abstract_grammar}), reserving a concrete grammar, presented as an extension of the abstract grammar, to support a graphical language but which has no implication in the semantics of the language.

\begin{figure}[h]
\includegraphics[width=0.95\textwidth]{grl_abstract_grammar}
\centering
\caption[GRL Abstract Grammar]{GRL Abstract Grammar defined in~\citefield{ituZ151}{journaltitle}}
\label{fig:grl_abstract_grammar}
\end{figure}

A GRL goal graph is a connected graph of intentional elements that optionally reside within an actor. The one shown in figure~\ref{fig:WirelessIN_Integrated_GRLGraph} targets the evaluation of an architectural decision about where to put the data and the logic of the authorization service of a wireless system~\citep{amyot2011user}.

\begin{figure}[h]
\includegraphics[width=0.85\textwidth]{WirelessIN-Integrated-GRLGraph}
\centering
\caption[Example of a GRL graph model]{Example of a GRL graph model~\citep{amyot2011user}}
\label{fig:WirelessIN_Integrated_GRLGraph}
\end{figure}

A goal graph, such as the one in figure~\ref{fig:WirelessIN_Integrated_GRLGraph}, shows the non-functional requirements and business goals of interest to the system and its stakeholders, as well as the alternatives for achieving these high-level elements. 

Figure~\ref{fig:WirelessIN_Integrated_GRLGraph} shows a particular configuration of alternatives (indicated by a star (*) and a dashed outline), consisting of assigning an initial qualitative satisfaction level of \emph{satisficed} to service control point for data location and mobile switch for service location, and the impact this decision has on the satisfaction levels of stakeholders, namely the system and service provider and their goals. Note that the algorithm used in figure~\ref{fig:WirelessIN_Integrated_GRLGraph} combined qualitative and quantitative contributions and the numbers (between $-100$ and $100$) are a quantitative measure of the satisfaction levels of goals and stakeholders. It can be seen that the strategy chosen resulted in a a satisfaction level for the service provider measured at $39$, while the system obtained 100. Accordingly, the goals of the system have been fully satisficed whilst the ones of the service provider have only been partially (or in GRL terminology, weakly) satisficed. Interestingly, in spite of minimum switch load, a softgoal of the service provider being denied, the impact of that decision on high throughput was low as high throughput had been decomposed in two softgoals and minimum message exchange was satisficed fully. 

GRL defines the following qualitative contribution levels as standard (their equivalent quantitative contribution is also shown):
\begin{table}[h!]
\caption[GRL contribution levels in jUCMNav]{GRL contribution levels in jUCMNav}
\label{tb:grl_contribution_levels}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.75}{
\begin{tabularx}{.6\textwidth}{cc}
\toprule \multicolumn{1}{c}{\bfseries{Contribution Type}}&
\multicolumn{1}{c}{\bfseries{Value}}\\
\addlinespace
\midrule
Make & 100 \\ \midrule
Some Positive & 75 \\ \midrule
Help & 25 \\ \midrule
Unknown & 0 \\ \midrule
Hurt & -25 \\ \midrule
Some Negative & -75 \\ \midrule
Break & -100 \\ 
\addlinespace
\bottomrule
\end{tabularx}
}
\end{table}

This evaluation mechanism propagates low-level decisions regarding alternatives to satisfaction ratings of high-level stakeholder goals and softgoals. GRL strategies can be compared with each other to help reach the most appropriate trade-offs among often conflicting goals of stakeholders. Colour coding of the intentional elements also reflect their satisfaction level (the greener, the more satisfied)~\citep{amyot2011user}.

\subsection{Summary}

In this chapter we have reviewed the notion of non-functional requirements and the multiple classification and representation schemes available. We followed with expanding on the importance of goals and goal-oriented approaches in the elicitation, analysis and modelling of stakeholders requirements, and in particular, quality attributes of the systems and applications that will help stakeholders attain those goals. Finally, we introduced GRL, by describing two other languages from which it spawn from, namely the \emph{NFR Framework} and \emph{i*}. While describing GRL, we focused on explaining how it supports reasoning about goals and requirements, while showing the impact of proposed alternative solutions to achieve those goals.

In the following chapters, we will introduce goal-oriented ideas and concepts in behaviour-driven development (BDD), and in doing so, offer a treatment of \nfrs as a first-class concept in BDD.

\chapter{Extending BDD -- A goal oriented approach}
\label{ch:Extendingbdd}
In previous chapters we have presented definitions of requirements and requirements engineering, paying particular attention to the practices concerning requirements elicitation, analysis, specification and validation found in most agile development methods, and BDD in particular.

We share the view that goal-oriented analysis complements and strengthens traditional requirements engineering techniques by offering a mechanism for capturing and evaluating alternative ways of meeting high-level goals~\citep{MylopoulosExpl2001}.

Eliciting high level goals early in the development process is crucial. However, goal-oriented requirements elicitation is an activity that continues as development proceeds, as high-level goals (such as business goals) are refined into lower-level goals (such as technical goals that are eventually operationalised in a system). Eliciting goals focuses the requirements engineer on the problem domain and the needs of the stakeholders, rather than on possible solutions to those problems~\citep{Nuseibeh:2000ub}. In addition, the requirements engineer needs to explore alternatives and evaluate their feasibility and desirability with respect to business goals.

This focus on the needs of stakeholders, even if logical and beneficial, has led to other goals, such as cross-cutting concerns or quality concerns of stakeholders, being neglected or addressed later in the software life-cycle. In fact, incorporating these goal types, such as \nfrs, into the different phases of the software life-cycle is a very hard task. Researchers face many challenges including their great diversity,  subjective nature, difficulty in formalisation, incorporating these requirements into models used for specifying functional requirements and resolving conflicts among \nfrs~\citep{Matoussi:2008wr}. Behaviour-driven development is one such model, traditionally used for specifying functional requirements and where their non-functional counterparts are rarely given the same relevance. 

In this chapter we present, through publicly available data, an application of our extension to BDD to a subset of the requirements of a case study dataset, including the treatment of \nfrs as first class citizens alongside functional requirements. Moreover, our approach is independent of the particular taxonomy chosen and remains faithful to the principles of agile development discussed in earlier chapters. 

The next chapter will focus on the changes made to Gherkin to support our methodology and also, detail a translator from feature files specified in Gherkin to GRL.

\section{Methodology}
We may be overusing the word methodology, given that some authors consider BDD not to be a methodology in its own right~\citep{Smart201410}. The extension we are proposing to BDD does not make it a full blown methodology (e.g. we are mostly silent regarding management of requirements using BDD) but it is useful to refer to our collection of methods and techniques using one word other than BDD, hence the choice for \emph{methodology}.

There are not that many references in the literature for approaches to handling non-functional requirements in agile methods, and the ones that exist are consistent with each other.~\citet{Davies} argues that agile teams should take responsibility for eliciting non-functional requirements and they should do it early-on by discussing with users the capabilities of the system, like quality of service and longevity, at the start of the project. The author lists three approaches to describe these required capabilities in agile methods : use the usual story format; factor \nfrs into acceptance criteria for affected user stories; and introduce `technical stories' to cover those additional requirements. A team at Connextra is credited with the following story card format~\footnote{~see http://agilecoach.typepad.com/photos/connextra\_user\_story\_2001/connextrastorycard.html for examples}:

\begin{displayquote}
\textbf{As a} \textit{\textless Actor \textgreater}, \textbf{I want} \textit{\textless Goal \textgreater}, \textbf{So that} \textit{\textless Benefit \textgreater}
\end{displayquote}

\citet{CohnNFRS} advises the use of the story format and gives examples where, in his view, non-functional characteristics can be expressed using the template above

\begin{displayquote}
\textbf{As a} CTO, \textbf{I want} the system to use our existing orders database rather than create a new one, \textbf{So that} we don't have one more database to maintain
\end{displayquote}

or

\begin{displayquote}
\textbf{As a} user, \textbf{I want} the site to be available 99.999 percent of the time I try to access it, \textbf{So that} I don't get frustrated and find another site to use
\end{displayquote}

Trying to write \nfrs in this template is a good exercise, as it helps make sure we understand who wants what and why, as the above examples demonstrate. \citet{CohnNFRS} points out though that we should pay attention not to get obsessed with this format and instead specify it in whatever way feels natural, if using the template leads to confusingly formed sentences.

In our research, we found the user story format appropriate for writing both functional and non-functional requirements. Our extension to Gherkin requires writing requirements in user story format, as we need to differentiate the goal from the stakeholder/role it intends to benefit. We do not believe this to be a significant drawback, but it does represent a breaking change with existing feature files. A refactoring to the extended Gherkin parser described in chapter~\ref{ch:gherkin_redux} could relax this constraint and allow existing features to be parsed successfully.

In this work, we use the approach of~\citet{Chung:2009vg} of considering as non-functional requirements, any `-ilities', `-ities', such as usability or security, along with many other things that do not necessarily end with either of them, such as performance or user-friendliness. From the perspective of mathematical functions, in the form of $\mathit{function} : \mathit{Input} \rightarrow \mathit{Output}$, just about anything that addresses characteristics of a function, a function's input or output or relationships between the two, can be considered as non-functional requirement.

\citet{Leffingwell2011} identifies, together with functional and non-functional requirements, design constraints as another class of requirements (see table~\ref{tb:three_req_types}). Design constraints typically originate from one of three sources: some necessary restriction of design options, conditions imposed on the development process itself, and regulations and imposed standards.

\begin{table}[h!]
\caption[Three types of requirements]{Three types of requirements~\citep{Leffingwell2011}}
\label{tb:three_req_types}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.75}{
\begin{tabularx}{\textwidth}{cX}
\toprule \multicolumn{1}{c}{\bfseries{Requirement Type}}&
\multicolumn{1}{c}{\bfseries{Description}}\\
\addlinespace
\midrule
Functional requirements & Express how the system interacts with its users-its inputs, its outputs, and the functions and features it provides \\ \midrule
Non-functional requirements &  Criteria used to judge the operation or qualities of a system \\ \midrule
Design constraints & Restrictions on the design of a system, or the process by which a system is developed, but that must be fulfilled to meet technical, business, or contractual obligations \\
\addlinespace
\bottomrule
\end{tabularx}
}
\end{table}

Our approach integrates all of the above requirements in a coherent manner, where both non-functional requirements and design constraints are treated as softgoals that can be specified alongside functional requirements. In extending BDD, our research aimed at integrating goal-reasoning concepts, while being shaped by the philosophy and principles of agile development. In other words, we extend BDD by 

\begin{itemize}
\item following a lightweight approach;
\item requiring minimal changes to Gherkin;
\item preventing subversion of the spirit behind \emph{Specification by Example};
\item respecting the strengths of BDD and GRL;
\item following a separation of concerns approach when integrating Gherkin and GRL.
\end{itemize}

In what follows, we will be assuming an iterative development approach, even though the description of the steps involved will be sequential. That is the nature of writing, and more so when documenting the results of technical research. We use a similar approach as~\citet{Chung2000} of following a process of developing a target artefact by starting with a source specification and producing constraints upon the target artefact. This could occur at various phases of development (e.g., requirements specification, conceptual design, or development).

The \emph{NFR Framework} uses non-functional requirements such as security, accuracy, performance and cost to drive the overall design process~\citep{Chung2000}. BDD in turn, uses expected behaviours of a system to drive the development process. We assume a hybrid approach, by retaining its behaviour-driven characteristics, but adding constrains derived from non-functional requirements.

Analogously to the \emph{NFR Framework}, there are several major steps in this process:
\begin{itemize}
\item acquiring or accessing knowledge of the particular domain and the system which is being developed, functional requirements for the particular system, and particular kinds of NFRs, and associated development techniques;
\item identifying particular NFRs for the domain;
\item decomposing NFRs;
\item deducing `operationalisations' (possible design alternatives for meeting NFRs in the target system);
\item dealing with ambiguities, trade-offs and priorities, and interdependencies among NFRs and operationalizations;
\item selecting operationalisations;
\item supporting decisions with design rationale;
\item evaluating the impact of decisions.
\end{itemize}

Again, these steps are not followed in sequence and we do not intend to introduce each, one at a time. It will be clear from the presentation, what each step consists of and when it is being applied.

In presenting our results and describing our methodology, we will make use of case study data contained on the \emph{PROMISE}~(Predictor Models in Software Engineering) requirements dataset~(\emph{PROMISE}, 2015). This dataset consists of 625 requirements collected from 15 software development projects. Among them, 255 items are marked as functional requirements and the remaining 370 non-functional requirements items are classified into 11 categories, such as security, performance and usability.

One of the projects included in the dataset, is a \emph{meeting scheduler}. Functionally, the \emph{meeting scheduler} is required to create meetings, send invitations, book conference rooms, book room equipment and so on. The \emph{meeting scheduler} example includes 27 functional requirements and 47 \nfrs, covering different aspects of the system, such as interoperability, usability, security, user friendliness, etc. The dataset also specifies for each non-functional requirement if it traces to a functional requirement, that is if that functional requirement is somehow constrained by the non-functional requirement. That mapping is presented in Appendix~\ref{ch:case_study_appendix}, table~\ref{tb:scheduler_original_frs_to_nfrs} (the absence of a particular non-functional requirement identifier from the columns of the table, implies there is no dependency between that non-functional and any of the functional requirements). The entire list of original functional and non-functional requirements of the \emph{meeting scheduler} case study can also be found in Appendix~\ref{ch:case_study_appendix}. Note that to facilitate tracing to the original \emph{PROMISE} dataset we are retaining the requirements identifiers used therein.

We were unsatisfied with the choice of taxonomy used in the dataset, as the data contains no guidance or indication is this respect. Also, some of the categorisations used were arguably inconsistent. For example, functional requirement 48 is originally impacted by non-functional requirements 138, 140, 142 and 162 and all of these have been categorised as Operational, whilst in our view 138 and 140 are more pertinent to interoperability constraints and 142 is more of a design constraint, rather than a specific non-functional requirement.

We also took into consideration an ontological approach and analysis conducted on this case study dataset~\citep{MylopoulosOnt2014}. That classification includes three basic categories of requirements, `functional requirement (FR)', `quality requirement (QR)', and `constraints over function (CF)'. These would be modelled by functional goals, quality goals and function constraints in their conceptual model. They have also identified an additional category, `Domain Assumption (DA)' that, in their words, can operationalise any other goal.

They analysed the 47 \nfrs within the dataset, and identified 21 QRs, 9 FRs, 14 Qrs+FRs, 2 CF+QR, and 1 DA. In the interest of space, we have decided to ignore any non-functional requirement that has been identified as FR, given that treating these would have no other consequence than growing our list of functional requirements to address. Therefore, and for the above reason, requirements 140 and 142 were removed from our list of \nfrs to take into consideration.

In this context, we opted to use the categorization in~\citefield{ieee_std_25010}{journaltitle}, and illustrated in figure~\ref{fig:iso25010} for easy referencing.

In what follows, we use 10 \nfrs (the ones that impact one or more of the functional requirements), with the meaning intended by Leffingwell, that is, requirements that define criteria used to judge the operation or qualities of a system~\citep{Leffingwell2011}. Other requirements, listed originally as non-functional requirements, fall into the category of design constraints, such as requirements with identifiers 139, \emph{`The product will function alongside server software on any operating system where the Java runtime can be installed'} or 141, \emph{`The product must make use of web/application server technology. Open source examples include Apache web server Tomcat and the JBoss application server'}. 

In the interest of space and keeping discussion relevant, we will address all three types of requirements, that is, functional, non-functional and design constraints, but will devote more attention to the requirements contained in the mapping table~\ref{tb:scheduler_original_frs_to_nfrs}. The reasons for this will become clear when we describe our extended format for feature files, as in our methodology, design constraints are addressed no differently than non-functional requirements with a global reach, one that causes them to have an impact on all other goals.

Before describing how we model this set of requirements using our extended BDD methodology, we need to surface some constraints that we were faced with and that shaped our approach. We had to assume that the list of requirements was consistent with the original goals of stakeholders, whoever they may be. This was the first hurdle we had to overcome, and that was identifying the different stakeholders of the system. Note that it was not our intention to identify all possible stakeholders, but rather only the ones that could be derived from the dataset.

We note also, that we did not have access to stakeholders and could not confirm assumptions, refine requirements or deal with ambiguities, or had access to business users from whom we could obtain further knowledge about the domain. This is not to say that we cannot use our methodology with confidence, it is just that we need to be appreciative of the constrained context in which our research took place.

In other words, our focus is on proving the feasibility (or not, for that matter) of our approach and to present the benefits, challenges and conclusions of our research. It is not to design the best possible \emph{meeting scheduler} given a set of elicited requirements. That would just not be possible without a significant amount of guess work. 

Chapter~\ref{ch:gherkin_redux} describes in detail the current Gherkin implementation and changes we introduced to the parser to support our methodology. Therein, we describe the current Gherkin class model. At the centre of the model are \emph{Features}, consisting of a name, a description, an optional list of tags and comments, and a list of \emph{Scenario Definitions} with an optional \emph{Background}. A name is synonymous with title, and description is a block of text in no particular format. \emph{Keyword} is filled by the parser and represents what lexeme was parsed (e.g. for a feature, one can use `Feature', `Business Need' or `Ability') when processing each line of a feature file. \emph{Background} adds context to the scenarios in a single feature and is similar to a scenario containing a number of \emph{Steps}. \emph{Tags} can be used to group features and scenarios together. Every \emph{scenario} consists of a list of \emph{Steps}, which must start with one of the keywords \emph{Given}, \emph{When}, \emph{Then}, \emph{But} or \emph{And}. These \emph{Steps}, are the interface to external tools to support testing and automated test execution approaches.

In the next section, we will introduce our changes to Gherkin by using a subset of requirements from the \emph{meeting scheduler} case study.

\section{Meeting scheduler case study}
\label{sec:case_study}
Based on the set of functional requirements (see table \ref{tb:scheduler_original_frs}), we devised the following list of stakeholders:

\begin{description}
\item[\emph{Procurement Manager}] \hfill \\
Represents the concerns and interests of those that select, purchase and buy software;
\item[\emph{Privileged User}] \hfill \\
Represents a user that due to reasons of seniority or others, has privileged access to a service or application;
\item[\emph{Meeting Organiser}] \hfill
Represents the concerns and interests of those users that want to organise meetings;
\item[\emph{Facilities Manager}] \hfill \\ 
Represents those individuals that are responsible for the security, maintenance and services of work facilities to ensure that they meet the needs of the organisation and its employees.
\end{description}

When addressing each requirement we determined which stakeholder the requirement pertains to. While there may be multiple stakeholders impacted by the requirement, in our approach only one of them will be associated with the requirement. This is a current limitation of our approach, even though for most practical purposes, and without loss of generality, each goal usually pertains to at most one stakeholder.
 
In order to describe changes to Gherkin we will make use of a subset of requirements from the \emph{meeting scheduler} case study. This subset of requirements is listed below.

\begin{table}[h!]
\caption[Exemplar subset of meeting scheduler requirements]{Exemplar subset of meeting scheduler requirements}
\label{tb:case_study_reqs_for_analysis}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.85}{
\begin{tabularx}{\textwidth}{cX}
\toprule \multicolumn{1}{c}{\bfseries{Requirement ID}}&
\multicolumn{1}{c}{\bfseries{Requirement Description}}\\
\addlinespace
\midrule
 R 48  & The product shall record meeting entries \\ \midrule
 R 63  & The product shall record updated meeting agendas \\ \midrule
 R 67  & The product shall record different meeting types \\ \midrule
 R 73  & The product shall have an intuitive user interface \\ 
\addlinespace
\bottomrule
\end{tabularx}
}
\end{table}

The reason that these requirements are of particular interest is that requirements 63 and 67 are impacted by 48, while 73 is a global non-functional requirement, in the sense that constrains all other functional requirements, and these variations cover all of our extensions to BDD.

Starting with requirement 48, it can be argued that recording meetings is of particular interest to the \emph{Meeting Organiser} role. We then introduce our first change to Gherkin, which is being able to specify requirements in user story format.

\begin{featurelist}{Changes to Gherkin -- User story format}{lst:gherkin_changes_userstory}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}
Feature:    R48 - The product shall record meeting entries

            As a Meeting Organiser
            I want to record meeting entries
            So that I can always access a persisted record of each meeting
\end{minted}
\end{featurecode}
\end{featurelist}

We introduce the concepts of an \emph{Actor}, in this case \emph{Meeting Organiser}, representing a stakeholder or system; a \emph{Goal}, in this case \emph{record meeting entries}, representing an actor's high-level desire or need and a \emph{Benefit}, in this case \emph{I can always access a persisted record of each meeting}, which represents the anticipated benefit for an actor if the specified goal is achieved.

\emph{Actors} are extremely relevant, as they represent stakeholders that usually have different, and at times conflicting, concerns, and not only do those need to be addressed and conflicts resolved, but also the actor's satisfaction level needs to be assessed.

\emph{Goals} equate very closely with functional requirements and it will be by satisfying them (and also \emph{Softgoals}, representing non-functional requirements and addressed later) that an actor's satisfaction level can be evaluated. \emph{Benefits} are used to document the perceived benefit of achieving a goal, and help justify modelling decisions in GRL.

\emph{Actors} and \emph{Goals} are GRL concepts (see chapter~\ref{ch:nfr_research},~section~\ref{sec:gore} for details on these concepts) that will be used by a Gherkin--to--GRL translator that will be described in chapter~\ref{ch:gherkin_redux}. \emph{Benefits} will not be translated to GRL as we did not find a suitable GRL element to map them to.

In order to address conflicts amongst \emph{Goals}, we extend the user story format with one or more references to other goals that may be impacted by a given goal~(see listing \ref{lst:gherkin_changes_impactedgoals}). The keyword used is \emph{Which may impact} followed by a \emph{Goal} that needs to be defined in another feature file.

\begin{featurelist}{Changes to Gherkin -- Impacted goals}{lst:gherkin_changes_impactedgoals}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}
Feature:    R48 - The product shall record meeting entries

            As a Meeting Organiser
            I want to record meeting entries
            So that I can always access a persisted record of each meeting
            Which may impact record a meeting agenda
            Which may impact record different meeting types

\end{minted}
\end{featurecode}
\end{featurelist}

The careful reader will have already identified \emph{record a meeting agenda} and \emph{record different meeting types} as the goals for requirements 63 and 67. To our knowledge, this is the first time that, in BDD practices, goals of stakeholders have been collectively addressed and potential conflicts or dependencies identified and taken into consideration. In GRL this will correspond to a \emph{Dependency} link.

If we refer to table~\ref{tb:scheduler_original_frs_to_nfrs}, which maps functional to non-functional requirements that impact them, we note that requirement 48 is constrained by an \emph{Interoperability} quality characteristic. That leads us to the next change, that is, attaching constraints to behaviours of systems or applications (see listing~\ref{lst:gherkin_changes_constraints}).

\begin{featurelist}{Changes to Gherkin -- Constraints}{lst:gherkin_changes_constraints}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}
Feature:    R48 - The product shall record meeting entries

            As a Meeting Organiser
            I want to record meeting entries
            So that I can always access a persisted record of each meeting
            Which may impact record different meeting types
            Which may impact record a meeting agenda
	
Constrained by:
            | Interoperability | Help |
\end{minted}
\end{featurecode}
\end{featurelist}

While the \emph{Feature} keyword is used to name and mark the beginning of a feature file, the keyword \emph{Constrained by} (note that \emph{Without ignoring} may also be used) lists the quality characteristics that constrain this functionality, and therefore should not be ignored. The lines immediately below are parsed as a table (using $\vert$ as a cell separator) to list the non-functional characteristics and the expected \emph{contribution} level for the satisfaction of the goal. In other words, and referring to this feature in particular, we expect Interoperability to \emph{help} (see section~\ref{sec:gore} for more on contribution levels) achieve the \emph{record meeting entries} goal. In GRL this will correspond to a \emph{Contribution} link.

\emph{Interoperability} is appropriate as a grouping term, but is not specific enough to support analysis. If we revert to mapping table~\ref{tb:scheduler_original_frs_to_nfrs} we can see that this requirement is impacted by four \nfrs, all related to the \emph{Interoperability} quality characteristic. Table~\ref{tb:three_nfrs_impacting_r48} lists those requirements.

\captionsetup[table]{list=no}
\begin{table}[h!]
\caption{Four \nfrs impacting functional requirement 48}
\label{tb:three_nfrs_impacting_r48}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.75}{
\begin{tabularx}{\textwidth}{cX}
\toprule \multicolumn{1}{c}{\bfseries{Requirement Type}}&
\multicolumn{1}{c}{\bfseries{Description}}\\
\addlinespace
\midrule
R 138   & The product must work with most database management systems (DBMS) on the market whether the DBMS is colocated with the product on the same machine or is located on a different machine on the computer network. \\ \midrule
R 140   & The product will require collaboration with a database management system (DBMS). The DBMS may be located on the same machine as the product or on a separate machine residing on the same computer network. \\    \midrule
R 142   & A database management system such as Oracle DB2 MySql or HSQL will need to be integrated with the product \\ \midrule
R 162   & The product must be able to interface with various database management systems. The product shall communicate successfully with the database management system on 100\textbackslash{}\% of all transactions. \\
\addlinespace
\bottomrule
\end{tabularx}
}
\end{table}
\captionsetup[table]{list=yes}

As we mentioned before, requirements 140 and 142 have been considered to be functional requirements~\citep{MylopoulosOnt2014} and therefore, will not receive our attention as they would need to be addressed in separate feature files and would complicate this description process further. We are then left with requirements with identifiers 138 and 162.

In BDD, and in the spirit of \emph{Specification by Example}, we clarify requirements details through examples; in the context of feature files, these are represented by \emph{Scenarios}. Listing~\ref{lst:gherkin_changes_scenarios} shows the revised feature file.

\begin{featurelist}{Changes to Gherkin -- Scenarios}{lst:gherkin_changes_scenarios}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}


Feature:    R48 - The product shall record meeting entries

            As a Meeting Organiser
            I want to record meeting entries
            So that I can always access a persisted record of each meeting
            Which may impact record different meeting types
            Which may impact record a meeting agenda
	
Constrained by:
            | Interoperability | Help |

@NFR
Scenario:   Meeting entries can be recorded in most DBMS
            Which helps Interoperability

@NFR	
Scenario:   100% of all transactions recording meeting entries in DBMS are successful
            Which helps Interoperability

Scenario:   Record simplest meeting
            Given the application has been started
            And I choose to add new meeting
            When I specify a meeting name and date
            And I proceed to save the meeting
            Then the meeting should be recorded
\end{minted}
\end{featurecode}
\end{featurelist}

Note that the two first scenarios are tagged \emph{NFR} to indicate they are examples of a non-functional characteristic. We also state the \emph{Contribution} level (\emph{Help}) of each particular scenario to the attainment of the quality desired, in this case, \emph{Interoperability}. We believe this communicates better what behaviour is expected from the system than would taking the individual requirements 138 and 162 on their own. The latter option made them slightly confusing as they seemed to overlap to some extent and were unrelated, where in fact they constrain the same functionality and contribute to attain the same \emph{Interoperability} quality.

We are also listing a third scenario, \emph{Record simplest meeting}, which is an ordinary BDD example detailing the expected behaviour of this feature. Because we are modelling behaviours using Goals, and in this particular case, the Goal is to \emph{record meeting entries}, this is equivalent of saying that \emph{Record simplest meeting}, if satisficed, contributes to the satisfaction of \emph{record meeting entries}. We have set an assumption, that if no contribution level is specified -- as in this case -- then a default contribution \emph{Help} level shall be used.

In GRL, we will use \emph{Tasks} to represent scenarios. The two situations described above are modelled using \emph{Contributions}, from \emph{Task} to \emph{Softgoal} in the first situation, and from \emph{Task} to \emph{Goal} in the second.\\

The complete feature file is listed below with remaining scenarios included.

\begin{featurelist}{Changes to Gherkin -- Complete feature}{lst:gherkin_changes_complete}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}

Feature:    R48 - The product shall record meeting entries

            As a Meeting Organiser
            I want to record meeting entries
            So that I can always access a persisted record of each meeting
            Which may impact record different meeting types
            Which may impact record a meeting agenda
	
Constrained by:
            | Interoperability | Help |

@NFR
Scenario:   Meeting entries can be recorded in most DBMS
            Which helps Interoperability

@NFR	
Scenario:   100% of all transactions recording meeting entries in DBMS are successful
            Which helps Interoperability
	
Scenario:   Record simplest meeting
            Given the application has been started
            And I choose to add new meeting
            When I specify a meeting name and date
            And I proceed to save the meeting
            Then the meeting should be recorded
	
Scenario:   Record meeting for a date in the past fails with a warning to the user
            Given the application has been started
            And I choose to add new meeting
            When I specify a date in the past
            And I proceed to save the meeting
            Then the meeting should not be recorded
            And the user is warned with an appropriate message
            Which helps record meeting entries

Scenario:   Record complex meeting
            Given the application has been started
            And I choose to add new meeting
            When I specify a meeting with 10 attendants
            And I choose an available conference room
            And I request a projector to be available
            And I proceed to save the meeting
            Then the meeting should be recorded
            With some positive contribution to record meeting entries
            Contributing to help Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

A last point to make regarding this feature is that it is possible to specify, for the same scenario, contributions to both the feature's goal and one or more quality characteristics (refer to scenario \emph{Record complex meeting}). Note that, on these occasions, the scenario should not be tagged with \emph{NFR}, as it is not an example of a quality requirement only, but rather an example of a feature's goal that also happens to contribute towards a quality characteristic.

The remaining features, corresponding to requirements with identifiers 63 and 67, can be found in listings \ref{lst:feature_r63} and \ref{lst:feature_r67}.

\begin{featurelist}{Changes to Gherkin -- R63 -- The product shall record updated meeting agendas}{lst:feature_r63}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}
Feature:    R63 - The product shall record updated meeting agendas

            As a Meeting Organiser
            I want to record a meeting agenda
            So that I can have access to the details of the meeting
	
Constrained by:
            | Interoperability | Help |

Scenario:   Record meeting agenda with details in text

Scenario:   Record meeting agenda with details in HTML

@NFR	
Scenario:   Meeting agendas can be recorded in most DBMS
            Which helps Interoperability

@NFR	
Scenario:   100% of all transactions recording meeting agendas in DBMS are successful
            Which helps Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{Changes to Gherkin -- R67 -- The product shall record different meeting types}{lst:feature_r67}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}

Feature:    R67 - The product shall record different meeting types

            As a Meeting Organiser
            I want to record different meeting types
            So that I can chose the most appropriate type of meeting
	
Constrained by:
            | Interoperability | Help |

Scenario:   Record one to one meeting

Scenario:   Record team meeting
	
@NFR	
Scenario:   Different Meeting types can be recorded in most DBMS
            Which helps Interoperability

@NFR
Scenario:   100% of all transactions recording different meeting \
            types in DBMS are successful
            Which helps Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

The last requirement to address is the one with identifier 73, and by doing so, we will introduce our last change to Gherkin, namely allowing the specification of global \nfrs or design constraints (see listing \ref{lst:feature_r73}). For easy reference, we list requirement 73 and \nfrs it is impacted by, in table~\ref{tb:case_study_cross_cutting}.

\begin{table}[h!]
\caption[Cross-cutting \nfrs]{Cross-cutting \nfrs}
\label{tb:case_study_cross_cutting}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.85}{
\begin{tabularx}{\textwidth}{cX}
\toprule \multicolumn{1}{c}{\bfseries{Requirement ID}}&
\multicolumn{1}{c}{\bfseries{Requirement Description}}\\
\addlinespace
\midrule
 R 73  & The product shall have an intuitive user interface \\ \midrule
 R 149 & The product shall allow for customization of start page and views preferences \\
\addlinespace
\bottomrule
\end{tabularx}
}
\end{table}

Note that this feature also introduces a new actor, namely \emph{Procurement Manager}, as we decided to model this cross-cutting concern as a goal of a stakeholder that carries that overall interest in the application's user interface and learnability characteristics. This learnability quality requirement is not something that was part of the original dataset, but a quality that we derived from our interpretation of the requirements.

\begin{featurelist}{Changes to Gherkin -- R73 -- The product shall have an intuitive user interface}{lst:feature_r73}
\begin{featurecode}{0.7}
\begin{minted}{Gherkin}
Feature:  R73 - The product shall have an intuitive user interface
			
            @GLOBAL
            As a Procurement Manager
            I want the product to have an intuitive interface
            So that all users are able to use the product without difficulty
	
Constrained by:
            | user interface aesthetics | Help	 |
            | Learnability	      | SomePositive |
		
@NFR		
Scenario:   Product has an intuitive interface
            Which makes user interface aesthetics
            Contributing to make Learnability
\end{minted}
\end{featurecode}
\end{featurelist}

These cross-cutting concerns (applies also to design constraints), will be distinguished from ordinary \nfrs by being tagged with a \emph{GLOBAL} tag, allowing the parser and, more importantly, the translator from Gherkin to GRL to treat them appropriately. In GRL, they will correspond to \emph{Dependency} links between the goal herein introduced (in this case, \emph{product to have an intuitive interface}) and all other goals introduced so far. That is, satisfaction of any other goal will be dependant on the satisfaction of this global reach goal.\\

We now turn our attention to GRL and how we can model the features covered so far. In chapter~\ref{ch:gherkin_redux} we will describe a translator from Gherkin to GRL. The output of that translator can be imported into jUCMNav~\footnote{~see http://jucmnav.softwareengineering.ca/ucm/bin/view/ProjetSEG/WebHome for details}, a free, Eclipse-based~\footnote{~see https://eclipse.org/ for details} graphical editor and analysis and transformation tool for the User Requirements Notation (URN), including GRL.

This tool has been described in detail before, first in Jean-Franois Roy's masters thesis~\citep{Roy:2007wyba} and later in a research paper~\citep{Amyot2010}, and we refer the interested reader to those two documents, as describing the tool in detail here is out of scope.

For now, we describe possible uses of the models imported into jUCMNav -- more precisely, a GRL catalogue of intentional elements, dependencies, contributions and decompositions -- that correspond to the Gherkin features just described, for requirements with identifiers 48, 63, 67 and 73. Figure~\ref{fig:InitialGRLGraph} shows a graph of the model that was imported into jUCMNav and that was generated using the translator described in chapter~\ref{ch:gherkin_redux}.

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{casestudy-initial}
\centering
\caption{Case study GRL Graph -- Initial}
\label{fig:InitialGRLGraph}
\end{sidewaysfigure}

The model shows two actors (modelled as circles drawn with dashed lines), and within each, their set of goals defined in the story format extension for feature files described earlier. We can also observe dependencies (thick lines with a filled arrow in the middle) pointing from a dependent goal to others it depends upon (e.g. \emph{Record a meeting agenda} depends upon \emph{Record meeting entries}). 

Also, all global qualities have incoming dependencies from all other goals (e.g. refer to \emph{Product to have an intuitive interface} in the graph).

Three \emph{Softgoals} are shown, namely \emph{Interoperability}, \emph{Learnability} and \emph{User interface aesthetics} that also correspond to the ones identified earlier. Note that these \emph{Softgoals} have to be previously defined, and our translator will ensure these are present by including a set of quality softgoals and decompositions with each run of the translator. We have chosen to base this set on the quality characteristics defined in~\citet{ieee_std_25010}, but a different categorisation scheme could be used. This process will be described in more detail in chapter~\ref{ch:gherkin_redux}.

The hexagons define \emph{Tasks} in GRL corresponding to scenarios defined in the feature files, with some contributing to Goals,  other to Softgoals, and others to both (e.g. \emph{Record complex meeting} contributes to \emph{Interoperability} softgoal and to \emph{Record meeting entries} goal).

The \emph{contribution} lines (thick lines with arrows at the end) show a symbol and also a numeric value to depict the intended contribution level). These correspond to the contribution levels described in section~\ref{sec:gore}.

Using GRL and the jUCMNav tool, we are able to develop analysis procedures by evaluating qualitative or quantitative satisfaction levels of the actors and intentional elements (e.g., goals and tasks) composing the model~\citep{Amyot2010}.

\citet{Amyot2010} mention that the analysis of goal models can be done in very different ways depending on the nature of the model and the purpose of the analysis. We believe that in our methodology, there are at least two types of analysis worth considering. 

The first one consists of taking the model as it currently is, and assigning initial satisfaction levels to some of the leaf nodes corresponding to the \emph{Tasks} in the model. This relates to scenarios being satisficed (or not) and triggering the satisfaction levels of goals and actors. In early stages of the software life-cycle, we may be interested in modelling the potential impact of scenarios in goal satisfaction of one or more stakeholders. In later stages, perhaps we have those scenarios already implemented and satisfied and want to assess current satisfaction levels of actors, in order to determine how far we may be from delivering software or application that satisfies its stakeholders sufficiently.

The second analysis type considers design options for \emph{Tasks} and/or \emph{Goals} and then checks the impact of those decisions on the satisfaction levels of goals and actors. The process is very similar to the above, but here we are delving into the design domain and considering alternative options to operationalise -- with the meaning intended by the \emph{NFR Framework} -- goals and tasks.

We will now show instances of these two types of analysis; but before proceeding, we need to specify \emph{importance} levels for each of the goals that are bound to an Actor. For what follows, we set the importance of \emph{Record meeting entries} to \emph{High}, of \emph{Record a meeting agenda} to \emph{Medium} and of \emph{Record different meeting types} to \emph{Low}. The goal \emph{Product to have an intuitive interface} was also set to \emph{High} as it is the only goal for the actor \emph{Procurement Manager}, and that seemed like a logical thing to do. This assignment of importance levels to goals bound to actors is enforced by jUCMNav, without which we would not be able to assess the satisfaction level of actors in the model.
 
We will start by first considering using the model as it currently is. Initial satisfaction levels for some of the intentional elements are provided in a \emph{strategy} and then propagated to the other ones through the various links that connect them. We start by satisfying all \emph{Tasks} corresponding to `functional' scenarios (see figure~\ref{fig:casestudy-functionalscenarios}), that is, those that are not tagged with \emph{NFR}.

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{casestudy-functionalscenarios}
\centering
\caption{Case study GRL Graph -- All functional scenarios satisfied}
\label{fig:casestudy-functionalscenarios}
\end{sidewaysfigure}

We note that both goals and actors have their satisfaction level untouched (showing zero on top of their respective icon). This is consistent with our expectation, since all goals are dependent on the \emph{Product to have an intuitive interface} which we haven't yet specified a satisfaction level for, and the current strategy did not cause a change to its satisfaction level. It is interesting to note the impact on both goals and actors of setting the satisfaction of that global constraint to either \emph{Satisfied} (see figure~\ref{fig:casestudy-functionalscenarios-globalconstraint}) or \emph{Weakly Denied} (see figure~\ref{fig:casestudy-functionalscenarios-globalconstraint-denied}). The latter satisfaction level could be interpreted, for example, as an indication of some users being dissatisfied with the user interface or the team facing implementation issues with the application's user interface.

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{casestudy-functionalscenarios-globalconstraint}
\centering
\caption{Case study GRL Graph -- All functional scenarios and global constraint satisfied}
\label{fig:casestudy-functionalscenarios-globalconstraint}
\end{sidewaysfigure} 

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{casestudy-functionalscenarios-globalconstraint-denied}
\centering
\caption{Case study GRL Graph -- All functional scenarios satisfied, global constraint weakly denied}
\label{fig:casestudy-functionalscenarios-globalconstraint-denied}
\end{sidewaysfigure} 

What can be confirmed from the model is the importance that quality \emph{Product to have an intuitive interface} has on the satisfaction level of goals and actors. When it is weakly denied the satisfaction level of other goals and actors is constrained to the minimum of their own satisfaction levels and the one of the global quality (e.g. -49 in this case). This should be a sign that the agile team should dedicate more attention and resources to improve attainability of that quality (this could be achieved by fixing any issues found or investing time in improving the current implementation).

We can also consider design alternatives and perform an assessment of the relative effectiveness of these alternatives at the requirements level~\citep{Amyot2010}. Figure~\ref{fig:casestudy-designoptionsA} shows the same model as before but where some design options have been considered. In particular, \emph{High availability} has been considered as a design option to help ensure $100\%$ of all transactions in DBMS~\footnote{~Database Management Systems (DBMS)} are successful; one of \emph{Use ORM}~\footnote{~Object Relational Mapping} or \emph{Use standard T-SQL only} were considered as options to attain interoperability with most DBMSs and two distinct options were considered to address the constrain specified that the product should have an intuitive interface. The particular strategy chosen is a valid one, as it ensures that all goals and actors attain a positive satisfaction level. It may not be adequate if, for example, there are other strategies that provide a better satisfaction level for the \emph{Meeting Organiser} and this has been considered a key stakeholder.

Figure~\ref{fig:casestudy-designoptionsB} shows the same model as before, with the same design options considered but with a different strategy. Here, by using an \emph{external UI library} the satisfaction level of goals and actors is improved, even though \emph{Interoperability} as a quality is \emph{Weakly Denied}. This may be an acceptable strategy, if we are trying to maximise satisfaction levels of actors and goals and attaining \emph{Interoperability} is not as important.

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{casestudy-designoptionsA}
\centering
\caption{Case study GRL Graph -- Design options considered (Option A)}
\label{fig:casestudy-designoptionsA}
\end{sidewaysfigure}

\begin{sidewaysfigure}
\includegraphics[width=\columnwidth]{casestudy-designoptionsB}
\centering
\caption{Case study GRL Graph -- Design options considered (Option B)}
\label{fig:casestudy-designoptionsB}
\end{sidewaysfigure}

\section{Summary}
In this chapter, and in the context of BDD, we have described a methodology that addresses \nfrs in tandem with functional requirements. We have done it by introducing a goal-oriented approach to the elicitation, analysis and modelling of requirements as aspirational goals of one or more identified stakeholders of an application or system.

We initially described, through a series of small transformational steps, the set of required changes to Gherkin, in order to translate requirements into goals, determine any dependencies and conflicts between goals, and more identify constraints to the satisfaction of those goals.

We have made use of a well known public dataset, and sampled a subset of functional and non-functional requirements to support the description of our methodology. In doing so, we have showed how requirements specified in Gherkin can be later modelled as a GRL graph in a specialised tool such as jUCMNav.

In the next chapter we will describe in detail the implementation changes to the Gherkin parser and also introduce a translator to convert one or more feature files into a GRL catalogue suitable to be imported into jUCMNav, for further modelling, refinement and analysis.

\chapter{From Gherkin to GRL}
\label{ch:gherkin_redux}
In the previous chapter we have exemplified how to use the proposed extension to BDD, handling \nfrs as first-class citizens alongside functional requirements. In order to achieve this undertaking, we had to alter the Gherkin parser to allow additional constructs.

In this chapter we are detailing the changes made to the Gherkin parser by showing relevant code extracts accompanied with explanations, in order to better describe those changes. We will be using version 3 of the Gherkin parser~\footnote{~see https://github.com/cucumber/gherkin3 for details}, a version that responds to issues with previous versions~\footnote{~ see discussion in https://groups.google.com/forum/\#!msg/cukes/YLKsqbBMBoI/DYhfFx8GBegJ for details} (e.g. difficulty in adding support for new languages; difficulty in compiling source code, so releases are very infrequent).

We will also detail a translator from Gherkin to an XML-based interchange format to be imported in a GRL tool (jUCMNav) and that allows goal modelling and analysis, and supports evaluation of satisfaction levels of actors and goals.

\section{Gherkin Extended}
\label{sec:gherkin_extended}
When using the word Gherkin we can be referring to the language, the parser or the compiler. Gherkin is a parser and compiler for the Gherkin language -- a domain specific language for the specification and documentation of requirements, focusing on the expected behaviours of a system or application using scenarios as examples. In what follows the intended meaning of the use of the word Gherkin should be clear from the context of use, and if not, we will clarify its intended meaning.

Gherkin (both parser and compiler) is implemented in multiple platforms and target languages including \emph{.NET / C$\#$}, \emph{JVM / Java}, \emph{Javascript / Browser or Node.js}, etc. Note that in what follows, we are using the \emph{.NET / C\#} version of the Gherkin parser. The following diagram provides an overview of the architecture of Gherkin

\begin{figure}[h!]
\includegraphics[width=0.85\textwidth]{gherkin_overview}
\centering
\caption[Gherkin Overview]{Gherkin Overview~\footnotemark}
\label{fig:gherkin_overview}
\end{figure}
\footnotetext{~sourced and replicated from https://github.com/cucumber/gherkin3}

The scanner reads a feature file and creates a token for each line. The tokens are passed to the parser, which outputs an AST -- a hierarchical syntactic structure of the source program commonly generated by parsers and parser generators -- to be used by the compiler. If the scanner sees a \emph{\# language header}, it will reconfigure itself dynamically to look for Gherkin keywords for the associated language. The parser is generated by the \emph{Berp}~\footnote{~ see https://github.com/gasparnagy/berp for details and source code} parser generator as part of the build process. Berp takes a grammar file (\emph{gherkin.berp}) and a template file (\emph{gherkin-X.razor}) as input, and outputs a parser in language X~(see figure~\ref{fig:berp_overview}).

\begin{figure}[h!]
\includegraphics[width=0.75\textwidth]{berp_overview}
\centering
\caption[Berp Overview]{Berp Overview~\footnotemark}
\label{fig:berp_overview}
\end{figure}
\footnotetext{~sourced and replicated from https://github.com/cucumber/gherkin3}

The keywords are defined in a file named \emph{gherkin-languages.json}. Listing below shows a section of that file containing English keywords only, including new ones added as part of this research and that are shown within a shaded area below. The new keywords are \emph{asA}, \emph{iWant}, \emph{soThat}, \emph{qualityAttribute}, \emph{scenarioContribution} and \emph{whichMayImpact}. 

\definecolor{ashgrey}{rgb}{0.7, 0.75, 0.71}

\tikzmark{JsonList}
\begin{featurelist}{Extended Gherkin -- English keywords}{lst:gherkin_keywords}
\begin{featurecode}{0.7}
\begin{minted}{json}
{ "en": {
        "and":	          [ "* ", "And " ],
        "background":           [ "Background" ],
        "but":	          [ "* ", "But " ],
        "examples":             [ "Examples", "Scenarios" ],
        "feature":              [ "Feature", "Business Need", "Ability" ],
        "given":                [ "* ", "Given " ],
        "name":                 "English",
        "native":               "English",
        "scenario":             [ "Scenario" ],
        "scenarioOutline":      [ "Scenario Outline", "Scenario Template" ],
        "then":                 [ "* ", "Then " ],
        "when":                 [ "* ", "When " ],
        "asA":                  [ "As a " ],
        "iWant":                [ "I want to ", "I want the " ],
        "soThat":               [ "So that " ],
        "qualityAttribute":     [ "Without ignoring" , "Constrained by"],
        "scenarioContribution": [
            "Breaking the ", "Which breaks ", "Contributing to break ",
            "Helping the ", "Which helps ", "Contributing to help ",
            "Hurting the ", "Which hurts ", "Contributing to hurt ",
            "Making the ", "Which makes ", "Contributing to make ",
            "With some positive contribution to ",
            "With some negative contribution to " 
                                ],
        "whichMayImpact":       [ "Which may impact " ]
       }
}
\end{minted}
\end{featurecode}
\begin{tikzpicture}[remember picture,overlay]
\draw[fill=ashgrey,opacity=0.2] ([yshift=-9.65cm,xshift=0.5cm]JsonList) rectangle ([yshift=-5.0cm,xshift=15cm]JsonList);
%\draw[fill=ashgrey,opacity=0.2] ([yshift=-90.65cm,xshift=0.5cm]JsonList) rectangle ([yshift=-5.0cm,xshift=15cm]JsonList);
\end{tikzpicture}
\end{featurelist}

It is important to note that Gherkin has been localised in several languages, and in our research we only extended the English language keywords, but it would be relatively easy to add support for more languages. Gherkin uses \emph{JSON}~(Javascript Object Notation)~\footnote{~see http://json.org/ for details} -- a lightweight data-interchange format -- to represent keywords in all supported languages.

As we mentioned before the parser generates an AST that can be used in back-end stages of compilers or as an intermediate representation that other tools can use. We will make use of this representation when we describe a translator from Gherkin to GRL. The following class diagram shows a class model of the AST generated by the original parser that does not include our modifications.

\begin{figure}[h!]
\includegraphics[width=0.85\textwidth]{gherkin3_ast}
\centering
\caption[Original Gherkin class model]{Original Gherkin class model~\footnotemark}
\label{fig:gherkin_ast}
\end{figure}
\footnotetext{~sourced from https://github.com/cucumber/gherkin3}

In the diagram every class represents a node in the AST. Every node has a \emph{Location} that describes the line and column number in the input file. A requirement of the implementation is that the AST must have a JSON representation, so that the parser can be tested.

At the centre of the model are \emph{Features} that consist of a name, description, an optional list of tags and comments, and a list of \emph{Scenario Definitions} with an optional \emph{Background}. A name is synonymous with a title, and description is a block of text in no particular format. \emph{Keyword} is filled by the parser and represents what lexeme was parsed (e.g. for a feature, one can use `Feature', `Business Need' or `Ability') when processing each line of a feature file. \emph{Background} adds context to the scenarios in a single feature and is similar to a scenario containing a number of \emph{Steps}. \emph{Tags} can be used to group features and scenarios together. Every \emph{Scenario} consists of a list of \emph{Steps} which must start with one of the keywords \emph{Given}, \emph{When}, \emph{Then}, \emph{But} or \emph{And}. These \emph{Steps} are the interface to external tools to support testing and automated test execution approaches.
\clearpage

In order to introduce our alterations, we now present a revised class model of the AST returned by the modified parser.

\begin{figure}[h!]
\includegraphics[width=0.95\textwidth]{gherkin_ast_new2}
\centering
\caption[Updated Gherkin class model]{Updated Gherkin class model (shaded nodes are new)}
\label{fig:gherkin_ast_new}
\end{figure}

The first change replaced the \emph{description} attribute of a \emph{Feature} by a \emph{FeatureDescription}. As any other node in the AST, a \emph{FeatureDescription} contains a \emph{Location} node (that link is not shown to prevent cluttering the diagram).

Recall from chapter~\ref{ch:Extendingbdd} that we decided to represent features using the Connextra user story format (reproduced again below)

\begin{displayquote}
\textbf{As a} \textit{\textless Actor \textgreater}, \textbf{I want} \textit{\textless Goal \textgreater}, \textbf{So that} \textit{\textless Benefit \textgreater}
\end{displayquote}

For this reason, \emph{FeatureDescription} contains a reference to an \emph{Actor}, a \emph{Goal} and a \emph{Benefit} node representing the segments within the user story format above. These three new nodes hold the \emph{keyword} matched, which for an actor is `As a ', for a goal is either `I want to ' or `I want the ' and for a benefit is `So that ' (listing~\ref{lst:gherkin_keywords} contains all of these keywords) and the lexeme parsed, which is the remaining content of the line being parsed without keyword and cleared of any spaces in between. With what has been described so far feature in listing~\ref{lst:gherkin_changes_userstory} could be parsed successfully.

The next change introduced a composition between \emph{FeatureDescription} and \emph{Goal} to support specifying dependencies between goals. \emph{FeatureDescription} has a collection (possibly empty) of \emph{impacted goals}. With this additional change feature in listing~\ref{lst:gherkin_changes_impactedgoals} could be parsed successfully.

Another composition was added between \emph{FeatureDescription} and \emph{QualityAttribute} to support attaching quality constraints to goals. The keywords supported are `Without ignoring' and `Constrained by'. The first could be used whenever the intention is on the attainment of those qualities and the second when instead, we intend to surface the fact that one or more qualities constrain the particular goal being modelled.

The last remaining change was to add a composition between \emph{Scenario} and \emph{Scenario Contribution} to allow specifying the contribution each \emph{Scenario} can have to the feature's goal or to a quality.

Listing~\ref{lst:changes_to_gherkin_grammar} shows an extract of the relevant parts of the alterations to the \emph{Berp} grammar for the Gherkin language. \emph{Berp} uses a syntax similar to BNF~\footnote{~Backus-Naur Form is a widely used notation to specify the syntax of languages} and provides support for languages without explicit tokenization rules, such as Gherkin. The symbols $+, ?, *$ have the same meaning as the one used in regular expressions syntax. Tokens are preceded with a \# character and some of them can be ignored such as in the cases of comments or spaces.

Production rules can be read as in any context-free grammar. As an example, the first production rule states that a \emph{Feature} can have the following form: a \emph{Feature\_Header} composed of an optional \emph{Language} token, optional \emph{Tags}, which are one or more \emph{TagLine} tokens; an optional \emph{Background} (production for background not shown in this listing, as we did not change it), a \emph{Feature\_Description} and zero or more \emph{Scenario\_Definition}. In order to fully understand this production rule we have to do the same for production rules not expanded, that is \emph{Background}, \emph{Feature\_Description} and \emph{Scenario\_Definition}.

\begin{featurelist}{Changes to gherkin grammar}{lst:changes_to_gherkin_grammar}
\begin{featurecode}{0.65}
\begin{minted}[breaklines=false]{ebnf}
...

Feature! := Feature_Header Background? Feature_Description Scenario_Definition*

Feature_Header! := #Language? Tags? #FeatureLine

Feature_Description! := Tags? #AsA_Step #IWant_Step #SoThat_Step WichMayImpact* Quality_Step?

Quality_Step!  := #QualityAttributeLine DataTable

WichMayImpact!  := #WichMayImpact

Scenario_Definition! := Tags? (Scenario | ScenarioOutline)

Scenario! := #ScenarioLine Scenario_Step* ScenarioContribution*

ScenarioContribution! := #ScenarioContribution

Tags! := #TagLine+
...

\end{minted}
\end{featurecode}
\end{featurelist}

We now turn attention to the code of the Gherkin parser. Listing~\ref{lst:gherkin_code_parser_construction} shows the classes involved in the creation of a \emph{Parser} object. The parser makes use of a \emph{TokenScanner} to read the feature file line by line and create \emph{Tokens} assigned with a \emph{Location} object with details of the current position in the input file.

\emph{TokenMatcher} has two responsibilities: one is to setup a \emph{GherkinDialect} object -- corresponds to the deserialised version of the JSON content listed earlier -- that is capable of recognizing the keywords in the default English language or in the language specified in the feature file; the other is to match parsed lexemes with tokens returned by \emph{TokenScanner}. Listing~\ref{lst:gherkin_code_parser_construction} shows the initial steps in constructing a \emph{Parser} object.

\emph{ASTBuilder} is responsible for building the AST based on the token or tokens parsed already. It keeps a stack of parsed nodes and whenever a production rule has been `activated' in its entirety, a node is popped from the stack and the current AST node replaced with a transformed one. An extract of the transformation function can be seen in listing~\ref{lst:gherkin_code_parser_transform_token} 

\begin{featurelist}{Parser construction}{lst:gherkin_code_parser_construction}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{csharp}
\\ somewhere, perhaps on a test file, a parser object is constructed
var parser = new Parser();
var parsingResult = parser.Parse(testFeatureFile);

\\ which in turn, causes this constructor to be invoked
public Parser() : this(new AstBuilder<T>())
{
}

// and this, setting an astBuilder private readonly object
public Parser(IAstBuilder<T> astBuilder)
{
    this.astBuilder = astBuilder;
}

\\ then the Parser's Parse method is invoked
public Feature Parse(string sourceFile)
{
    using (var reader = new StreamReader(sourceFile))
    {
        return Parse(new TokenScanner(reader));
    }
}

// After which, the Parse method in generic base class Parser<Feature> is invoked
public T Parse(ITokenScanner tokenScanner)
{
    return Parse(tokenScanner, new TokenMatcher());
}
\end{minted}
\end{featurecode}
\end{featurelist}

Listing~\ref{lst:gherkin_code_parser_execution} is the core method where parsing actually occurs. After a set of initialisation instructions the parser runs a \emph{Berp} generated state machine.

\begin{featurelist}{Parser execution}{lst:gherkin_code_parser_execution}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{csharp}
// The main loop where parsing occurs
public T Parse(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher)
{
    tokenMatcher.Reset();
    astBuilder.Reset();
    var context = new ParserContext
    {
        TokenScanner = tokenScanner,
        TokenMatcher = tokenMatcher,
        TokenQueue = new Queue<Token>(),
        Errors = new List<ParserException>()
    };

    StartRule(context, RuleType.Feature);
    int state = 0;
    Token token;
    do
    {
        token = ReadToken(context);
        state = MatchToken(state, token, context);
    } while(!token.IsEOF);

    EndRule(context, RuleType.Feature);

    if (context.Errors.Count > 0)
    {
        throw new CompositeParserException(context.Errors.ToArray());
    }

    return GetResult(context);
}
\end{minted}
\end{featurecode}
\end{featurelist}

The Gherkin parser generator (\emph{Berp}) generates several functions that are used to determine the transition from a state to the next, based on a matched token. Listing~\ref{lst:gherkin_code_parser_execution_token_matching} shows the matching function when the parser engine is on state $0$ and has called \emph{TokenScanner} for the next \emph{Token}. The function listed correspond to the production rule for a \emph{Feature}~(see listing~\ref{lst:changes_to_gherkin_grammar}).

The parsing is complete when the \emph{TokenScanner} returns an \emph{EOF} \emph{Token}, time at which the feature file has been read until the end. Last step is to retrieve from the stack the last node and pass it through the transformation function in listing~\ref{lst:gherkin_code_parser_transform_token}.

\begin{featurelist}{Parser execution -- Token Matching }{lst:gherkin_code_parser_execution_token_matching}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{csharp}
// Start
int MatchTokenAt_0(Token token, ParserContext context)
{
    if (Match_Language(context, token))
    {
        StartRule(context, RuleType.Feature_Header);
        Build(context, token);
        return 1;
    }
    if (Match_TagLine(context, token))
    {
        StartRule(context, RuleType.Feature_Header);
        StartRule(context, RuleType.Tags);
        Build(context, token);
        return 2;
    }
    if (Match_FeatureLine(context, token))
    {
        StartRule(context, RuleType.Feature_Header);
        Build(context, token);
        return 3;
    }
    if (Match_Comment(context, token))
    {
        Build(context, token);
        return 0;
    }
    if (Match_Empty(context, token))
    {
        Build(context, token);
        return 0;
    }
    
    const string stateComment = "State: 0 - Start";
    token.Detach();
    var expectedTokens = new string[] {"#Language", "#TagLine", "#FeatureLine",
                                        "#Comment", "#Empty"};
    var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token,
                                                                          expectedTokens,
                                                                          stateComment) 
        : new UnexpectedTokenException(token, expectedTokens, stateComment);
    if (StopAtFirstError)
        throw error;
    
    AddError(context, error);
    return 0;
}
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage
\begin{featurelist}{Parser execution -- Building AST nodes}{lst:gherkin_code_parser_transform_token}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=true]{csharp}
\\ the end of a production rule has been reached will build a node of the AST
private object GetTransformedNode(AstNode node)
{
 switch (node.RuleType)
 {
    // ... Other case statements ommitted
    case RuleType.WichMayImpact: 
    {
        var impactedGoalNode = node.GetToken(TokenType.WichMayImpact);
        return new Goal(GetLocation(impactedGoalNode), impactedGoalNode.MatchedKeyword, impactedGoalNode.MatchedText);
    }
    case RuleType.Feature_Description:
    {
       var tags         = GetTags(node);
       var actorLine    = node.GetToken(TokenType.AsA_Step);
       var actor        = new Actor(GetLocation(actorLine), actorLine.MatchedKeyword, actorLine.MatchedText);
       var goalLine     = node.GetToken(TokenType.IWant_Step);
       var goal         = new Goal(GetLocation(goalLine), goalLine.MatchedKeyword, goalLine.MatchedText);
       var benefitLine  = node.GetToken(TokenType.SoThat_Step);
       var benefit      = new Benefit(GetLocation(benefitLine), benefitLine.MatchedKeyword, benefitLine.MatchedText);

       var impactedGoals = node.GetItems<Goal>(RuleType.WichMayImpact).ToArray();
       var qualities     = node.GetSingle<QualityAttributes>(RuleType.Quality_Step);
   
       return new FeatureDescription(tags, GetLocation(actorLine), actor, goal, benefit, impactedGoals, qualities);
    }
    case RuleType.Feature:
    {
       var header              = node.GetSingle<AstNode>(RuleType.Feature_Header);
       var tags                = GetTags(header);
       var featureLine         = header.GetToken(TokenType.FeatureLine);
       var featureDescription  = node.GetSingle<FeatureDescription>(RuleType.Feature_Description);                   
       var background          = node.GetSingle<Background>(RuleType.Background);
       var scenariodefinitions = node.GetItems<ScenarioDefinition>(RuleType.Scenario_Definition).ToArray();
       var description         = GetDescription(header);
       var language            = featureLine.MatchedGherkinDialect.Language;

       return new Feature(tags, GetLocation(featureLine), language, featureLine.MatchedKeyword, featureLine.MatchedText, featureDescription, background, scenariodefinitions, comments.ToArray());
    }
 }
 return node;
}
\end{minted}
\end{featurecode}
\end{featurelist}

\clearpage
\section{Gherkin to GRL Translator}
\label{sec:grl_translator}
The fact that the Gherkin parser returns an AST allows for other tools to take that intermediate representation and use it to translate Gherkin instances to different formats. Listing~\ref{lst:translator_to_grl_main} below contains the relevant section of the body of the translator program from instances of Gherkin to GRL for use in jUCMNav.

\begin{featurelist}{Translator to GRL -- main body}{lst:translator_to_grl_main}
\begin{featurecode}{0.70}
\begin{minted}[breaklines=true]{csharp}
// Load Default Quality Catalogue
var lastAssignedId = 0;
var defaultQualityCatalogue = QualityCatalogue.BuildDefault(out lastAssignedId);

// Initialise a grlCatalogue
var grlCatalogue = GRLCatalogueFactory.NewGRLCatalog(DEFAULT_CATALOGUE_NAME, DEFAULT_CATALOGUE_DESC, DEFAULT_CATALOGUE_AUTHOR);

var generator = new GRLCatalogueGenerator();

// Avoid parsing features twice by collecting parsing results
var parsingResults = new Ast.Feature[] { };

// Prepend qualities from default catalogue
generator.AppendQualityCatalogue(defaultQualityCatalogue,grlCatalogue);

// Process all feature files passed as arguments
foreach (var featureFiles in args)
{
 var parsingResult = UpdateGRLCatalogueWithFeature(featureFiles, grlCatalogue, generator);
 parsingResults = parsingResults.Concat(new [] { parsingResult } ).ToArray();
}

// Add any dependencies amongst goals. Can only run when all features have been processed
foreach (var parsingResult in parsingResults)
{
    generator.UpdateGRLCatalogueWithImpactedGoals(grlCatalogue, parsingResult);
}

// Add any global goals. Need to have access to all AST trees to ensure no dependencies between global goals are created
generator.UpdateGRLCatalogueWithGlobalGoals(grlCatalogue, parsingResults);

// Serialise resulting GRL Catalogue
var grlCatalogueAsXmlString = XMLSerializerHelper.SerializeObject(grlCatalogue);
Console.WriteLine(XMLSerializerHelper.RemoveBOM(grlCatalogueAsXmlString));
\end{minted}
\end{featurecode}
\end{featurelist}

The translator works by populating an object model derived from the XSD schema defined in Appendix~\ref{ch:grl_catalogue_schema} -- created using \emph{xsd.net}, a well known \emph{.NET} serialisation tool~\footnote{~see https://msdn.microsoft.com/en-us/library/x6c1kb0s(v=vs.110).aspx for details} -- in a sequence of logical steps. 

These steps are implemented in a \emph{GRLCatalogueGenerator} object that contains the logic required to create goals, softgoals, tasks, links between them and set containment of goals within actors. The caller, in this case the translator main method, is responsible for orchestrating the calls to the right methods and at appropriate times.

The first step consists of populating the GRL catalogue with a default set of quality characteristics and sub-characteristics. In this work we use the ones defined in~\citefield{ieee_std_25010}{journaltitle}, but others could be used as easily.

\begin{featurelist}{Translator to GRL -- default quality set (Partial)}{lst:translator_to_grl_populate_default_qualities}
\begin{featurecode}{0.70}
\begin{minted}[breaklines=true]{csharp}
public static string[][] DEFAULT_QUALITY_CATALOGUE_SPEC = {
// Product Quality Charactristics and sub-characteristics
new [] {NextId,"Functional suitability","And", 
        NextId,"Functional completeness", 
        NextId,"Functional correctness", 
        NextId,"Functional appropriateness"},
new [] {NextId,"Performance efficiency","And", 
        NextId,"Time behaviour", 
        NextId,"Resource utilization", 
        NextId,"Capacity"},
new [] {NextId,"Compatibility","And", 
        NextId,"Co-existence", 
        NextId,"Interoperability"},
...
};       
\end{minted}
\end{featurecode}
\end{featurelist}

Listing~\ref{lst:translator_to_grl_populate_default_qualities} contains an extract of those qualities. We use a multi-dimensional array where each element is another array containing one particular characteristic and zero or more sub-characteristics. The first two elements of that array are the identifier and name; the third element is the type of decomposition to use (we only use \emph{AND} decompositions, but others like \emph{OR} and \emph{XOR} could also be used), and the other elements, processed in groups of two elements at a time are the sub-characteristics identifier and name. For example \emph{Compatibility} is a quality with two sub-qualities, namely \emph{Co-Existence} and \emph{Interoperability}. We use a global element identifier to ensure all elements are assigned a unique and incremental id. From this list of qualities we build a \emph{QualityCatalogue} class model as shown in figure~\ref{fig:quality_catalogue}.

\begin{figure}[h!]
\includegraphics[width=0.85\textwidth]{quality_catalogue}
\centering
\caption[Default quality catalogue class model]{Default quality catalogue class model}
\label{fig:quality_catalogue}
\end{figure}

Note that in the graphs in section~\ref{sec:case_study} we remove any parent and child nodes without any outgoing links to reduce cluttering. This is the reason why only \emph{Interoperability} is shown and not the complete quality hierarchy with parent \emph{Compatibility} and sibling \emph{Co-existence}.

Once default qualities have been added to the catalogue, the next step is to individually process all feature files passed in as arguments to the translator. The translator will invoke the Gherkin parser for each feature file and pass the results to the generator object instructing it to perform a first pass through each of the ASTs returned by the parser.

The reason we mention first pass, is because of the nature of impacted goals and global constrains or, in other words, the way links are established within the catalogue. The translator has to do a first pass on ASTs so that all intentional elements are created, so that on a second pass dependencies between elements can be added, as these require goals involved in the dependency to be already defined.

\begin{featurelist}{Translator to GRL -- update catalogue with AST}{lst:translator_to_grl_update_with_AST}
\begin{featurecode}{0.70}
\begin{minted}[breaklines=false]{csharp}
public void UpdateGRLCatalogue(grlcatalog grlCatalogue, Ast.Feature parsingResult)
{
    // Add new actor element or retrieve existing one from container
    var actorElement = AddActorToGRLCatalogue(parsingResult, grlCatalogue);
    
    // Add new goal (This is the "I want to..." goal of a BDD Feature)
    var goalElement = AddFeatureGoalToGRLCatalogue(parsingResult, grlCatalogue);
    
    // Attach goal to Actor
    BindElementToActorAndUpdateGRLCatalogue(grlCatalogue, 
                                            actorElement, goalElement);
    
    // Are there any non-functionals?
    if (parsingResult.Description != null 
        && parsingResult.Description.QualityAttributes != null 
        && parsingResult.Description.QualityAttributes.Qualities.Length > 0)
    {
        // Add Qualities
        AddQualitiesToGRLCatalogue(parsingResult, grlCatalogue, actorElement);
    
        // Add Contribution Links from qualities to goal
        AddQualityGoalContributionsToGRLCatalogue(parsingResult, 
                                                  grlCatalogue, goalElement);
    }
    
    // Are there any scenarios?
    if (parsingResult.ScenarioDefinitions != null 
        && parsingResult.ScenarioDefinitions.Count() > 0) 
    {
        // Add contributions from scenarios to goal
        AddScenarioGoalContributionsToGRLCatalogue(parsingResult,
                                                   grlCatalogue, goalElement);
    }
}
\end{minted}
\end{featurecode}
\end{featurelist}

Processing each AST includes adding (if not already present) the actor to the catalogue, the new goal to the catalogue and setting containment of this goal to the actor. If this goal is constrained by any qualities then these qualities and contributions from each quality to the feature's goal is added to the catalogue. Similar consideration is done if the AST contains nodes for parsed scenarios. 

We will not be listing all of these auxiliary methods as they all follow a similar pattern described next (figure~\ref{lst:translator_to_grl_add_actor} contains an example of one such method).

\begin{featurelist}{Translator to GRL -- add actor to catalogue}{lst:translator_to_grl_add_actor}
\begin{featurecode}{0.75}
\begin{minted}[breaklines=true]{csharp}

private grlcatalogActor AddActorToGRLCatalogue(Ast.Feature parsingResult, grlcatalog grlCatalogue)
{
  var actor = parsingResult.Description.Actor;

  // Create or obtain actor element from container
  var actorExists = false;
  var actorElement = container.RegisterElement<grlcatalogActor>(actor.Name, out actorExists);

  // Only add to catalogue if not already present
  if (!actorExists)
    grlCatalogue.actordef = grlCatalogue.actordef.Union(new[] { actorElement }).ToArray();

  return actorElement;
}
\end{minted}
\end{featurecode}
\end{featurelist}

Each of these methods has access to a \emph{GRLElementsContainer}, an implementation of the \emph{Registry} pattern~\footnote{~see http://martinfowler.com/eaaCatalog/registry.html for details} and that creates new and locates existing elements that have been added to the catalogue.

This object is very important as it allows finding elements already added in the catalogue by name or description which is all that an AST returned by Gherkin has access to. The GRL catalogue instead requires all elements, and links between them, to have identifiers and use them to establish those links.

Each of the elements to be registered in the catalogue implement an \emph{IElementWithIdentity} interface that ensures they have a valid identifier, name, and description, which is used in registering and locating an element in the registry, but also in code generation to produce the GRL catalogue as all elements are required to have those attributes. Listing~\ref{lst:translator_to_grl_registry} shows the most relevant methods of the registry object.

\begin{featurelist}{Translator to GRL -- a Registry object for GRL elements}{lst:translator_to_grl_registry}
\begin{featurecode}{0.70}
\begin{minted}[breaklines=false]{csharp}
class GRLElementsContainer
{
 private Dictionary<int, IElementWithIdentity> registry;
 private int lastAssignedId = 0;
 
 public int Add<T>(T value) where T : class, IElementWithIdentity
 {
     if (value == null)
         throw new ApplicationException("Cannot register null object in GRLContainer");
     if (registry.Any(keyval => keyval.Value.name == value.name))
         throw new ApplicationException("Cannot register value as it already exists");
     registry.Add(++lastAssignedId, value);
     return lastAssignedId;
 }
 
 public T GetElementByName<T>(string name) where T : class, IElementWithIdentity
 {
   if (registry.Any(keyval => keyval.Value.name == name))
     return registry.First(keyval => keyval.Value.name == name).Value as T;
   return null;
 }
 
 public T RegisterElement<T>(string name, out bool exists) where T : class, 
                                                                 IElementWithIdentity, 
                                                                 new()
 {
   T intElement = new T();
   exists = false;
   var existingElement = GetElementByName<T>(name);
   if (existingElement != null)
   {
     exists = true;
     return existingElement;
   }

   var id = Add<IElementWithIdentity>(intElement);
   intElement.id          = id.ToString();
   intElement.name        = name;
   intElement.description = "";
   return intElement;
 }
\end{minted}
\end{featurecode}
\end{featurelist}

Once all feature files have gone through the first pass the parser invokes the generator's method \emph{UpdateGRLCatalogueWithImpactedGoals} which adds any dependencies amongst goals (if there are any). Figure~\ref{lst:translator_to_grl_global_goals} shows the method's implementation. 

\begin{featurelist}{Translator to GRL -- Add global goals}{lst:translator_to_grl_global_goals}
\begin{featurecode}{0.70}
\begin{minted}[breaklines=true]{csharp}

foreach (var parsingResult in parsingResults)
{
    var goalDescription = parsingResult.Description.Goal.Description;
    var goalElement = container.GetElementByName<grlcatalogIntentionalelement>(goalDescription);
    if (parsingResult.Description != null 
        && HasGlobalTag(parsingResult.Description))
    {
        foreach (var intentionalElement in grlCatalogue.elementdef)
        {
            var otherGoalElement = container.GetElementByName<grlcatalogIntentionalelement>(intentionalElement.name);
            var isGlobalGoal = parsingResults.Any(f => String.Compare(f.Description.Goal.Description,otherGoalElement.name,true)==0 && HasGlobalTag(f.Description));
        
            if (goalElement.id != otherGoalElement.id 
            && intentionalElement.type == "Goal" 
            && !isGlobalGoal)
            {
                var dependencyElement = BuildDependencyElement(goalElement, otherGoalElement);
                grlCatalogue.linkdef.dependency = grlCatalogue.linkdef.dependency.Union(new[] { dependencyElement }).ToArray();
            }
        }
    }
}
\end{minted}
\end{featurecode}
\end{featurelist}
It is important to note that we avoid adding a dependency if a reverse dependency already exists. For example if no safety check was in place, then two global goals A and B would create two dependencies $A \rightarrow B$ and $B \rightarrow A$ and that would break the GRL Catalogue consistency.

Last remaining step is to serialize the catalogue object by using simple \emph{.NET} object serialisation techniques.

\chapter{Conclusion}
\label{ch:Conclusion}
Most conventional approaches to system design are driven by functional requirements, where developers focus their efforts primarily on achieving the desired functionality of a product or system, usually considering non-functional requirements (such as cost and performance) in a non-systematic and often undocumented way~\citep{Chung2000}.

Our work helps to address two of the most common requirements risks which are ambiguous requirements and overlooked stakeholders~\citep[p. 20]{Wiegers2013}. By viewing requirements as goals of stakeholders that when satisfied produce some identified benefit, and by ensuring all stakeholders interests are reflected on identified features, we reduce the potential for overlooked stakeholders. Also, by providing examples of both functional and \nfrs, in the spirit of \emph{Specification by Example}, and by representing the latter as constrains to the former, we reduce the ambiguity in requirements elicitation and analysis methods.

Our work is also actual and contributes to major requirements engineering trends in recent years, including the increased use of agile development methods and the evolution of techniques for handling requirements on agile projects; the maturing of tools for assisting with requirements development activities and the increased use of visual models to represent requirements knowledge.

Writing the requirements isn't the hard part. The hard part is determining the requirements. Shortcomings in requirements practices pose many risks to project success, where success means delivering a product that satisfies the user's functional and quality expectations at the agreed-upon cost and schedule~\citep{Wiegers2013}. Our approach helps to determine requirements and builds on the foundational principles of agile development and BDD by extending Gherkin with constructs to represent actors, goals and their dependencies, constrains and global quality attributes. Using our extension to BDD, we are able to address not only the expected behaviours of a system but three types of complementary requirements~\citep{Leffingwell2011} -- functional, non-functional and design constrains -- in a coherent manner.

Documented and clear requirements greatly facilitate system testing. All of these increase chances of delivering high-quality products that satisfy all stakeholders~\citep{Wiegers2013}. Specifications in Gherkin use a ubiquitous language -- a common, rigorous language used between developers and users and based on a domain model -- that fosters communication and clarifies requirements. We benefit from these characteristics and extend their use to the systematic handling of \nfrs.

As the software industry matures, it becomes clearer that it is not enough just to deal with the description of the desired functionality, but that quality attributes need to be carefully thought of early on as well~\citep{Chung:2009vg}. Not only non-functional requirements need to be stated early on, but they help the software engineer make design decisions, while also justifying such decisions. However it is necessary that quality attributes not be considered just as a separate set of requirements, but with the consideration of the functionality throughout the development process~\citep{Chung:2009vg}.

\section{Related work}
\citet{Rosa2004} present a process-oriented approach defined around basic abstractions and in which functional and non-functional requirements are refined together in a semi-formal way. They define non-functional properties using a set of abstractions, namely \emph{NF-Attributes}, \emph{NF-Statements} and \emph{NF-Actions} and integrate them in architectures of software systems by associating them with architectural elements that are then refined into concrete implementations.

\citet{Araujo2005} define an `aspect-oriented agile requirements approach where initial cross-cutting requirements are modelled as coarse-grained scenarios. Scenarios are used as descriptions of desired or existing system behaviour and composition rules are defined to weave coarse-grained aspectual and non-aspectual scenarios to completely describe functionalities'.

Also exploring aspect-orientation and looking at reuse from a non-functional (quality) perspective, \citet{Leite2005} combine ideas from reuse, from goal-oriented requirements, aspect-oriented programming and quality management, to obtain a goal-driven process to enable a quality-based reusability of software artefacts. They propose a `goal-oriented representation language to support quality reusability introducing a representation for functions, topics, quality types, pre-conditions, pointcuts (relations among functions, topics and quality types), contribution structures and quality operationalizations'.

\citet{Franch1998} presented a proposal for putting non-functional information of software systems into software architectures. Non-functionality is described by means of a notation called \emph{NoFun}, which allows to introduce non-functional attributes of software, to give values to these attributes in component and connectors, and to formulate non-functional requirements in terms of these attributes.

There are three research streams that have influenced our work. The first one is closely related to ours, but comes from a different angle and is limited to some types of \nfrs~\citep{barmi2011automated}. They describe \emph{ProBDD}, an extension to BDD in which probabilistic \nfrs -- such as safety, security, and performance -- are specified in BDD scripts using specification patterns for probabilistic properties with a structured English grammar. The proposed extended BDD scripts can be parsed and executed with randomly generated input data and test results can verify the specified \nfrs fulfilment. 

Their work differs from ours as it is restricted to \nfrs that can be written as probabilistic statements (those that can be quantified and can be expressed in a probabilistic form). Also, their focus is on automated testing and validation of \nfrs while our approach is applicable to all \nfrs types; is independent of taxonomy chosen; and is intended to foster analysis, detection and management of dependencies and conflicts among \nfrs.

The second work describes the building blocks of a lightweight agile methodology (named \emph{NORMAP}) for identifying, linking, and modelling functional and non-functional requirements. \emph{NORMAP} aims to improve software quality and support agility~\citep{Farid1998}. They proposed \emph{Agile Use Cases (AUCs)} --  hybrid of use cases and agile user stories -- to model functional requirements, \emph{Agile Loose Cases (ALCs)} -- loosely-defined agile \nfrs --  and \emph{Agile Choose Cases (ACCs)} to model potential solutions (operationalizations) to \nfrs. The three artefacts are combined in a visual framework to promote agile modelling of \nfrs. They also enhanced the agile user story card to a new \emph{W8} Story Card Model that captures functional or non-functional agile requirements and that served as inspiration to the proposed constructs in Gherkin.

Finally, the foundational work laid by the \emph{NFR Framework}~\citep{Chung2000}, that first introduced the concept of `softgoal' and allowed the systematic handling of \nfrs and later influenced other goal-oriented approaches, such as GRL~\citep{Amyot2003} that we integrate in our research.

\section{Further research}
Our work has introduced changes in the Gherkin parser but has largely ignored its impact on the compiler. Further research is needed to adapt the compiler for these new constructs. This also implies the need to adapt existing tools such as Cucumber~\footnote{~see https://cucumber.io/ for details} or SpecFlow~\footnote{~ see http://www.specflow.org/ for details} to the new capabilities , so that they can assist in producing specifications in the modified Gherkin format. These tools could also play a role in interfacing between Gherkin and GRL by, for example, causing the successful execution of test cases to mark corresponding \emph{Tasks} in GRL as satisfied; or by supporting typical editor features such as intellisense and code completion, syntactic analysis, etc.

Further research is also required in applying the methodology to larger case studies, preferably originated in complex industrial settings, where the suitability of the practices and techniques described in this work can be assessed.

At the moment we only support forward generation of GRL models from Gherkin specifications. In an ideal scenario it would also be possible to do the reverse, that is, start with a GRL model of goals and softgoals, goal decompositions and dependencies among them, a set of actors, tasks and contributions to goals, and generate one or more Gherkin specifications. With those two generation models in place it would be easier to support full traceability and navigation between Gherkin and GRL models, offering the capability of doing updates in-place, where only modified parts of one model are seamlessly updated in the other.

Another area of future research consists in exploring interaction between our work and more formal and semi-formal languages that explore modelling approaches for capturing \nfrs. In one of such approaches, \citet{MylopoulosOnt2014} propose a modelling language for non-functional requirements that views them as requirements over qualities, mapping a software-related domain to a quality space. Their methodology refines informal \nfrs elicited from stakeholders, resulting in unambiguous, de-idealized, and measurable requirements. This would address a particular limitation with our approach, in which nothing intrinsic to it improves the capacity of requirements being measured or not. If such research is carried out, it is important to investigate the extent to which actors and goals satisfaction algorithms can be adapted to support requirements defined in such languages.

Another possible route for research would be to investigate the extent to which our work could be integrated with UCM -- a scenarios-based notation for gathering functional requirements such as operational or architectural requirements, supporting dynamic refinement at the behavioural and structural level~\citep{Roy:2007wyba} -- by exploring how scenarios in BDD can be mapped to their equivalent entities in UCM and determine how activities, tasks or functions within a system can be traced back to original BDD scenarios and be part of goal reasoning in GRL.

Our proposal does not solve completely all enunciated issues with the treatment of non-functional requirements in software development projects. However, our proposal is an effective step towards the explicit treatment of this kind of properties in agile software development, and BDD in particular, and establishes a defined agenda for research in this area.

\begin{appendices}
\chapter{Case Study}
\label{ch:case_study_appendix}
The table below lists all original functional requirements contained in the \emph{PROMISE} dataset. Note that for easy of referencing the tables below retain original requirement identifiers.

\begin{center}
\begin{longtable}{c m{.8\textwidth}}
\caption[Meeting scheduler original functional requirements]{Meeting scheduler original functional requirements~(\emph{PROMISE}, 2015)\label{tb:scheduler_original_frs}}\\
\toprule \multicolumn{1}{c}{\bfseries{Requirement ID}} & \multicolumn{1}{c}{\bfseries{Functional Requirement Description}}\\
 \addlinespace
 \midrule
 \endfirsthead
\multicolumn{2}{c}%
{\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
\toprule \multicolumn{1}{c}{\bfseries{Requirement ID}} & \multicolumn{1}{c}{\bfseries{Functional Requirement Description}}\\
 \addlinespace
 \midrule
\endhead
\multicolumn{2}{r}{\textit{Continued on next page}} \\
\endfoot
\addlinespace
\bottomrule
\endlastfoot   
    R 48  & The product shall record meeting entries \\ \midrule
    R 49  & The product will notify employees of meeting invitations \\ \midrule
    R 50  & The product shall have the ability to send meeting reminders to employees \\ \midrule
    R 51  & The product shall assign the organizers contact information to each meeting they create \\ \midrule
    R 52  & The product will record meeting acknowledgements \\ \midrule
    R 53  & The product shall store new conference rooms \\ \midrule
    R 54  & The product shall update existing conference rooms \\ \midrule
    R 55  & The product will be able to delete conference rooms \\ \midrule
    R 56  & The product shall be able to store new room equipment \\ \midrule
    R 57  & The product will update existing room equipment \\ \midrule
    R 58  & The product shall be able to delete room equipment \\ \midrule
    R 59  & The product shall allow an organizer to invite other employees to meetings \\ \midrule
    R 60  & Each time a conference room is reserved the conference room schedule shall be updated to reflect the time and date of the reservation \\ \midrule
    R 61  & The product shall record the transportation status of equipment reserved \\ \midrule
    R 62  & The product shall display a map of the company building showing conference room locations \\ \midrule
    R 63  & The product shall record updated meeting agendas \\ \midrule
    R 64  & The product shall send a meeting confirmation to the meeting organizer \\* \midrule
    R 65  & The product shall display room equipment according to search parameters \\ \midrule
    R 66  & The product shall display conference rooms according to search parameters \\ \midrule
    R 67  & The product shall record different meeting types \\ \midrule
    R 68  & The product shall record all the equipment that has been reserved \\ \midrule
    R 69  & The product shall notify building personnel of equipment transport requests \\ \midrule
    R 70  & The product will allow privileged users to view meeting schedules in multiple reporting views \\ \midrule
    R 71  & The product shall be able to send meeting notifications via different kinds of end-user specified methods \\ \midrule
    R 72  & The product shall have a customizable Look and Feel \\ \midrule
    R 73  & The product shall have an intuitive user interface \\ \midrule
    R 74  & The product will display an available status for unreserved conference rooms \\
\end{longtable}
\end{center}


The table below lists all the original non-functional requirements for the \emph{meeting scheduler} project included in  the \emph{PROMISE} dataset, including the classification proposed by \citeauthor{MylopoulosOnt2014} in \cite{MylopoulosOnt2014}.

\begin{center}
\begin{longtable}{c c m{.6\textwidth}}
\caption[Meeting scheduler original non-functional requirements]{Meeting scheduler original non-functional requirements~(\emph{PROMISE}, 2015)\label{tb:scheduler_original_nfrs}}\\
\toprule \multicolumn{1}{c}{\bfseries{Requirement ID}} & \multicolumn{1}{c}{\bfseries{Classification}} & \multicolumn{1}{c}{\bfseries{Non-functional Requirement Description}}\\
    \addlinespace
    \midrule
    \endfirsthead
\multicolumn{3}{c}%
{\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
\toprule \multicolumn{1}{c}{\bfseries{Requirement ID}} & \multicolumn{1}{c}{\bfseries{Classification}} & \multicolumn{1}{c}{\bfseries{Non-functional Requirement Description}}\\
    \addlinespace
    \midrule
\endhead
\multicolumn{3}{r}{\textit{Continued on next page}} \\
\endfoot
\addlinespace
\bottomrule
\endlastfoot
    R 138   & FR+QR & The product must work with most database management systems (DBMS) on the market whether the DBMS is colocated with the product on the same machine or is located on a different machine on the computer network. \\
    \midrule
    R 139   & FR+QR & The product will function alongside server software on any operating system where the Java runtime can be installed. \\    \midrule
    R 140   & FR & The product will require collaboration with a database management system (DBMS). The DBMS may be located on the same machine as the product or on a separate machine residing on the same computer network. \\    \midrule
    R 141   & QR & The product must make use of web/application server technology. Open source examples include Apache web server Tomcat and the JBoss application server. \\    \midrule
    R 142   & FR & A database management system such as Oracle DB2 MySql or HSQL will need to be integrated with the product \\    \midrule
    R 143   & FR+QR & The product's Look and Feel shall be able to incorporate aspects of the customer's organization such as logo branding and identity \\*    \midrule
    R 144   & QR & The product shall have a conservative and professional appearance \\    \midrule
    R 145   & QR & The product shall make the users want to use it. 80\textbackslash{}\% of the users surveyed report they are regularly using the product after the first 2 weeks postlaunch \\    \midrule
    R 146   & QR & The product shall be easy to use. 90\textbackslash{}\% of users will be able to successfully reserve a conference room within 5 minutes of product use \\*    \midrule
    R 147   & FR+QR & The product shall give users feedback when necessary. 80\textbackslash{}\% of the users surveyed report that the product accurately confirms their actions \\    \midrule
    R 148   & FR+QR & The product shall allow the user to select a chosen language from one of the target market countries \\ \midrule
    R 149   & FR+QR & The product shall allow for customization of start page and views preferences \\    \midrule
    R 150   & QR & An employee will be able to successfully use the product within a few minutes. After informally navigating the product for less than 15 minutes users shall be able to successfully setup meetings and reserve conference rooms \\    \midrule
    R 151   & QR & The product shall use a standard navigation menu familiar to most web users \\    \midrule
    R 152   & FR+QR & The product shall allow for intuitive searching of available conference rooms \\    \midrule
    R 153   & QR & The product shall conform to the Americans with Disabilities Act \\    \midrule
    R 154   & QR & The response shall be fast enough to avoid interrupting the user's flow of thought. 90\textbackslash{}\% of tasks shall complete within 5 seconds. 98\textbackslash{}\% of tasks shall complete within 8 seconds \\    \midrule
    R 155   & QR & Aside from server failure the software product shall achieve 99.99\textbackslash{}\% up time \\    \midrule
    R 156   & FR+QR &  The product shall create an exception log of problems encountered within the product for transmission to our company for analysis and resolution \\    \midrule
    R 157   & QR & The product shall be capable of handling up to 1 000 concurrent requests. This number will increase to 2 000 by Release 2. The concurrency capacity must be able to handle peak scheduling times such as early morning and late afternoon hours \\    \midrule
    R 158   & QR & The product shall be able to process 10 000 transactions per hour within two years of its launch. This number will increase to 20 000 by Release 2 \\    \midrule
    R 159   & QR & The product shall be expected to operate for at least 5 years for each customer installation \\    \midrule
    R 160   & DA & The product shall be used in office environments \\    \midrule
    R 161   & FR+QR & The product must be able to interface with any HTML browser. The product shall transmit data between the user and the product without problems. The product shall display HTML properly in 80\textbackslash{}\% of all HTML browsers tested (minimum is to test 8 browsers) \\    \midrule
    R 162   & FR+QR & The product must be able to interface with various database management systems. The product shall communicate successfully with the database management system on 100\textbackslash{}\% of all transactions. \\    \midrule
    R 163   & FR+QR & The product must be able to interface with various email servers. The product shall be able to send email \\    \midrule
    R 164   & FR & The product shall be available for distribution via the Internet as a binary or ZIP file \\    \midrule
    R 165   & FR & The product shall be available for distribution as a packaged CD \\    \midrule
    R 166   & FR & The product will be available for licensing as a one-server two-five servers or five-or-more servers license \\    \midrule
    R 167   & QR & A new user must be able to be added to the system within 10 minutes.90\textbackslash{}\% of new users are able to log into the system within 10 minutes \\    \midrule
    R 168   & QR & The product must be designed using Design Patterns and coding best practices. 90\textbackslash{}\% of maintenance software developers are able to integrate new functionality into the product with 2 working days \\    \midrule
    R 169   & QR & The product must be highly configurable for use with various database management systems for the end users. 80\textbackslash{}\% of end users are able to integrate new database management systems with the product without changing the product's software code \\    \midrule
    R 170   & QR & Maintenance releases will be offered to customers once a year. The releases shall take no longer than 5 minutes for 80\textbackslash{}\% of the customer base to install \\    \midrule
    R 171   & FR+QR & Every registered user will have access to the product's support site via the Internet. 70\textbackslash{}\% of registered users shall find a solution to their problem within 5 minutes of using the support site \\    \midrule
    R 172   & QR & The customer shall be able to easily integrate new building maps with the product throughout the product's life-cycle. Integration of new maps with the product shall be possible with little to no support from product support staff \\    \midrule
    R 173   & FR+QR & The product shall be translated into foreign languages other than the target market countries languages in future releases. For each emerging target market it shall take no more than 5 days to configure the product for that market's language \\    \midrule
    R 174   & FR+QR & The product is expected to integrate with multiple database management systems. The product will operate with Oracle SQL Server DB2 MySQL HSQL and MS Access \\    \midrule
    R 175   & QR & The product shall be able to be installed in any operating environment within 2 days \\    \midrule
    R 176   & CF+QR & The product shall ensure that only company employees or external users with company-approved user IDs may have product access. 100\textbackslash{}\% of all logons shall be by either company employees or external users with company-approved user IDs \\    \midrule
    R 177   & CF+QR & Only managers are able to perform search queries for reservations by user. 100\textbackslash{}\% of all search queries for reservations by user shall be from logons of only management logons \\    \midrule
    R 178   & FR+QR & The product shall ensure that the database's data corresponds to the data entered by the user. Each conference room reservation in the system will contain the same information as was entered by the user \\*    \midrule
    R 179   & FR+QR & The product shall prevent the input of malicious data. The product and/or adjacent hardware/software systems data shall remain 100\textbackslash{}\% uncorrupted each time malicious data is input into the product \\    \midrule
    R 180   & QR & The product and/or dependent databases/filesystems shall remain operational as a result of the input of malicious data. The product and/or dependent databases/filesystems shall not crash 100\textbackslash{}\% of the time that malicious data is input into the product \\    \midrule
    R 181   & FR+QR & The product shall have the ability to receive automatic software updates as new threats emerge. 100\textbackslash{}\% of customers will be able to receive automatic software updates transmitted to the installed product \\    \midrule
    R 182   & QR & The language of the product shall accommodate all of the target market countries. 90\textbackslash{}\% of survey respondents from each target market country will find that the language of the product is acceptable \\    \midrule
    R 183   & FR+QR & The product shall be able to display calendar dates and times according to the user's locale. 90\textbackslash{}\% of survey respondents from each target market country will find that the date and time formatting of the product is correct \\    \midrule
    R 184   & QR & The product must be developed with the J2SE/J2EE programming language libraries \\
\end{longtable}
\end{center}

\begin{table}[h!]
\caption[Meeting scheduler mapping of functional to non-functional requirements]{Meeting scheduler mapping of functional to non-functional requirements~(\emph{PROMISE}, 2015)}
\label{tb:scheduler_original_frs_to_nfrs}
\setlength{\extrarowheight}{1.8pt}
\centering
\scalebox{0.7}{
    \begin{tabular}{rrccccccccccccccccccccccccccccccccccccccccccccccc}
    \toprule
              & \multicolumn{11}{c}{\bfseries{Non-Functional Requirements}} \\
        \midrule
        \multicolumn{1}{c}{\bfseries{Req ID}} & \begin{turn}{45}R 138\end{turn} & \begin{turn}{45}R 140 (*)\end{turn} & \begin{turn}{45}R 142 (*)\end{turn} & \begin{turn}{45}R 146\end{turn} & \begin{turn}{45}R 149\end{turn} & \begin{turn}{45}R 152\end{turn} & \begin{turn}{45}R 162\end{turn} & \begin{turn}{45}R 163\end{turn} & \begin{turn}{45}R 168\end{turn} & \begin{turn}{45}R 178\end{turn} & \begin{turn}{45}\end{turn} \\
            \multicolumn{1}{c}{R 48} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       & \multirow{27}[54]{*}{} \\
            \multicolumn{1}{c}{R 49} & \multicolumn{10}{c}{\multirow{4}[8]{*}{}}                                     &  \\
            \multicolumn{1}{c}{R 50} & \multicolumn{10}{c}{}                                                         &  \\
            \multicolumn{1}{c}{R 51} & \multicolumn{10}{c}{}                                                         &  \\
            \multicolumn{1}{c}{R 52} & \multicolumn{10}{c}{}                                                         &  \\
            \multicolumn{1}{c}{R 53} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 54} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 55} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 56} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 57} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 58} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 59} & \multicolumn{10}{c}{}                                                         &  \\
            \multicolumn{1}{c}{R 60} &       &       &       & \multicolumn{1}{l}{O,P}   &       &       &       &       &       & \multicolumn{1}{l}{O}     &  \\
            \multicolumn{1}{c}{R 61} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 62} &       &       &       &       &       & \multicolumn{1}{l}{L}     &       &       & \multicolumn{1}{l}{MA,MO} &       &  \\
            \multicolumn{1}{c}{R 63} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 64} &       &       &       &       &       &       &       & \multicolumn{1}{l}{I}     &       &       &  \\
            \multicolumn{1}{c}{R 65} & \multicolumn{10}{c}{\multirow{2}[4]{*}{}}                                     &  \\
            \multicolumn{1}{c}{R 66} & \multicolumn{10}{c}{}                                                         &  \\
            \multicolumn{1}{c}{R 67} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 68} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       &       &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 69} & \multicolumn{10}{c}{}                                                         &  \\
            \multicolumn{1}{c}{R 70} & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     & \multicolumn{1}{l}{I}     &       & \multicolumn{1}{l}{AS}    &       & \multicolumn{1}{l}{I}     &       &       &       &  \\
            \multicolumn{1}{c}{R 71} &       &       &       &       &       &       &       & \multicolumn{1}{l}{I}     &       &       &  \\
            \multicolumn{1}{c}{R 72} &       &       &       &       & \multicolumn{1}{l}{AS}    &       &       &       &       &       &  \\
            \multicolumn{1}{c}{R 73} &       &       &       &       & \multicolumn{1}{l}{L,AS}  &       &       &       &       &       &  \\
            \multicolumn{1}{c}{R 74} &       &       &       & \multicolumn{1}{l}{O,P}   &       & \multicolumn{1}{l}{L}     &       &       &       &       &  \\
        \bottomrule
    \end{tabular}%
}
\caption*{
        \scalebox{0.75}{
            \begin{tabular}{c c c}
              \multicolumn{3}{c}{\multirow{3}[1]{*}{\emph{\bfseries{Legend:}} In the above, initials represent qualities}} \\
                &    & \\
                & \multicolumn{2}{c}{O  Operability} \\
                & \multicolumn{2}{c}{P  Pleasure} \\
                & \multicolumn{2}{c}{I  Interoperability} \\
                & \multicolumn{2}{c}{L  Learnability} \\
                & \multicolumn{2}{c}{MA Maintainability} \\
                & \multicolumn{2}{c}{MO Modifiability} \\
                & \multicolumn{2}{c}{AS User interface aesthetics} \\
                \multicolumn{2}{c}{\multirow{3}[1]{*}{\emph{\bfseries{(*)}} \citet{MylopoulosOnt2014} marked these as Functional requirements and we do not consider them in our work}} 
            \end{tabular}
        }
  }
\end{table}


\clearpage
\section{Case study requirements in BDD format}

In this section, we list the remaining feature files corresponding to the functional requirements in the \emph{meeting scheduler} case study and not addressed previously in chapter~\ref{ch:Extendingbdd}, section~\ref{sec:case_study}.
Note that in some listings the lines have been wrapped and a \verb|\|| used to show where the line breaks, to improve visibility but these line breaks should be removed if the text is to be submitted through Gherkin parser.

\begin{featurelist}{R53 -- The product shall store new conference rooms}{lst:feature_r53}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R53 - The product shall store new conference rooms
	
            As a Facilities Manager
            I want to record new conference rooms
            So that I can keep my facilities inventory updated
            Which may impact update existing conference rooms
            Which may impact delete conference rooms
			
Constrained by:
            | Interoperability | Help |

# This scenario does not include a contribution.
# Therefore, a default contribution from scenario to goal will be added
Scenario:   Record conference room with minimum details
            Given the application has been started
            And I choose to add new conference room
            When I specify a conference room name, building identifier and floor
            And I proceed to save the conference room
            Then the conference room should be recorded
@NFR	
Scenario:   Conference rooms can be recorded in most DBMS
            Contributing to help Interoperability
@NFR
Scenario:   100% of all transactions recording conference rooms in DBMS are successful
            Contributing to help Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R54 -- The product shall record meeting entries}{lst:feature_r54}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R54 - The product shall record meeting entries

            As a Facilities Manager
            I want to update existing conference rooms
            So that I can keep my facilities inventory updated
	
Constrained by:
            | Interoperability | Help |

Scenario:   Update conference room fields other than name

Scenario:   Product does not allow updating conference room field name

@NFR	
Scenario:   Conference rooms can be updated in most DBMS
            Contributing to help Interoperability

@NFR
Scenario:   100% of all transactions updating conference rooms in DBMS are successful
            Contributing to help Interoperability	
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage

\begin{featurelist}{R55 -- The product will be able to delete conference rooms}{lst:feature_r55}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R55 - The product will be able to delete conference rooms

            As a Facilities Manager
            I want to delete conference rooms
            So that I can keep my facilities inventory updated
		
Constrained by:
            | Interoperability | Help |

Scenario:   Delete conference room not associated with a meeting succeeds

Scenario:   Not possible to delete conference room with meetings associated

@NFR	
Scenario:   Conference rooms can be deleted from most DBMS
            Contributing to help  Interoperability

@NFR
Scenario:   100% of all transactions deleting conference rooms in DBMS are successful
            Contributing to help  Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R56 -- The product shall be able to store new room equipment}{lst:feature_r56}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R56 - The product shall be able to store new room equipment

            As a Facilities Manager
            I want to store new room equipment
            So that I can keep my conference rooms equipment inventory updated
            Which may impact update existing room equipment
            Which may impact delete room equipment
			
Constrained by:
            | Interoperability | Help |

Scenario:   Record room equipment with minimum details

Scenario:   Record room equipment with complete details

@NFR
Scenario:   Room equipment can be stored in most DBMS
            Contributing to help  Interoperability

@NFR
Scenario:   100% of all transactions storing room equipment in DBMS are successful
            Contributing to help  Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage

\begin{featurelist}{R57 -- The product will update existing room equipment}{lst:feature_r57}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R57 - The product will update existing room equipment

            As a Facilities Manager
            I want to update existing room equipment
            So that I can keep my conference rooms equipment inventory updated
			
Constrained by:
            | Interoperability | Help |

@NFR
Scenario:   Room equipment can be updated in most DBMS
            Contributing to help  Interoperability

@NFR
Scenario:   100% of all transactions updating room equipment in DBMS are successful
            Contributing to help  Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R58 -- The product shall be able to delete room equipment}{lst:feature_r58}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R58 - The product shall be able to delete room equipment

            As a Facilities Manager
            I want to delete room equipment
            So that I can keep my conference rooms equipment inventory updated
	
Constrained by:
            | Interoperability | Help |

Scenario:   Delete room equipment not associated with a meeting succeeds

# This scenario shows that by producing examples we can uncover other nfrs
Scenario:   Delete room equipment with a meeting associated notifies meeting organiser

@NFR
Scenario:   Notifications of deleted room equipment can be sent through \
            various email servers	
            Which helps Interoperability

@NFR	
Scenario:   Room equipment can be deleted from most DBMS
            Contributing to help  Interoperability

@NFR
Scenario:   100% of all transactions deleting room equipment from DBMS are successful
            Contributing to help  Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage

\begin{featurelist}{R60 -- Each time a conference room is reserved the schedule shall be updated}{lst:feature_r60}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R60 - Each time a conference room is reserved the conference room schedule \
            shall be updated to reflect the time and date of the reservation

            As a Meeting Organiser
            I want to reserve a conference room and update the schedule with the \
            meeting's date and time
            So that I prevent double bookings

Constrained by:
            | Operability | Help |
            | Pleasure    | Help |
@NFR	
Scenario:   Updated conference room schedule data in the database corresponds to the \
            data entered by the user
            Which helps Operability

@NFR
Scenario:   It is easy to reserve a conference room and update the schedule with the \
            meeting's date and time
            Which helps Operability
            Contributing to help Pleasure

@NFR	
Scenario:   90% of users are able to reserve a conference room within 5 minutes of use
            Which helps Operability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R61 -- The product shall record the transportation status of equipment reserved}{lst:feature_r61}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R61 - The product shall record the transportation status of equipment reserved

            As a Meeting Organiser
            I want to record the transportation status of equipment reserved
            So that I can verify when the equipment is available
	
Constrained by:
            | Interoperability | Help |

@NFR	
Scenario:   Transportation status of equipment reserved can be recorded in most DBMS
            Which helps Interoperability

@NFR	
Scenario:   100% of all transactions recording transportation status of equipment \
            reserved in DBMS are successful
            Which helps Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage

\begin{featurelist}{R62 -- The product shall display a map of the company building}{lst:feature_r62}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R62 - The product shall display a map of the company building showing \
            conference room locations

            As a Meeting Organiser
            I want to view a map of the company building
            So that I can see conference room locations and choose the best location \
            for the meeting
	
Constrained by:
            | Learnability    | Help |
            | Maintainability | Help |
            | Modifiability   | Help |

@NFR	
Scenario:   Product allows intuitive searching of available conference rooms
            Which helps Learnability
	
@NFR
Scenario:   Product is designed using Design Patterns and coding best practices
            Which makes Maintainability

@NFR
Scenario:   90% of maintenance software developers are able to integrate new \
            functionality into the product with 2 working days
            Which makes Modifiability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R64 -- The product shall send a meeting confirmation to the meeting organizer}{lst:feature_r64}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R64 - The product shall send a meeting confirmation to the meeting organizer

            As a Meeting Organiser
            I want to receive a meeting confirmation
            So that I can be sure the meeting has been recorded
	
Constrained by:
            | Interoperability | Help |

@NFR	
Scenario:   Meeting confirmations can be sent through various email servers
            Which helps Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage

\begin{featurelist}{R68 -- The product shall record all the equipment that has been reserved}{lst:feature_r68}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}
Feature:    R68 - The product shall record all the equipment that has been reserved

            As a Meeting Organiser
            I want to record all the reserved equipment
            So that I can be sure all equipment will be available for the meeting
	
Constrained by:
            | Interoperability | Help |

Scenario:   Reserve projector for a meeting is recorded

Scenario:   Reserve projector and board for a meeting is recorded	

@NFR	
Scenario:   All the reserved equipment can be recorded in most DBMS
            Which helps Interoperability

@NFR	
Scenario:   100% of all transactions recording all the reserved equipment \
            in DBMS are successful
            Which helps Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R70 -- The product will allow privileged users to view meeting schedules}{lst:feature_r70}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}
Feature:    R70 - The product will allow privileged users to view meeting schedules in \ 
            multiple reporting views

            As a Privileged User
            I want to view meeting schedules in multiple reporting views
            So that I can control schedules
	
Constrained by:
            | Interoperability          | Help         |
            | user interface aesthetics | SomePositive |

Scenario:   Display monthly view of scheduled meetings

Scenario:   Display view of scheduled meetings for a given conference room

Scenario:   Display view of scheduled meetings organised by a specific individual
	
@NFR	
Scenario:   All meeting schedules can be stored in most DBMS
            Which helps Interoperability

@NFR
Scenario:   100% of all transactions recording meeting schedules in DBMS are successful
            Which helps Interoperability

@NFR
Scenario:   Multiple reporting views can be customised
            Which helps user interface aesthetics
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage

\begin{featurelist}{R71 -- The product shall be able to send meeting notifications...}{lst:feature_r71}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R71 - The product shall be able to send meeting notifications via different \
            kinds of end-user specified methods

            As a Meeting Organiser
            I want to send meeting notifications via different kinds of end-user methods
            So that I can be sure I can contact all meeting attendees
	
Constrained by:
            | Interoperability | Help |

Scenario:   Send email notification

Scenario:   Send messaging notification

Scenario:   Meeting confirmations can be sent via different kinds of end-user specified \
            methods and through various email servers
            Which helps Interoperability
\end{minted}
\end{featurecode}
\end{featurelist}


\begin{featurelist}{R72 -- The product shall have a customizable look and feel}{lst:feature_r72}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R72 - The product shall have a customizable look and feel
			
            @GLOBAL
            As a Procurement Manager
            I want to customise the product's look and feel
            So that I can tailor the product to different departments and teams
	
Constrained by:
            | user interface aesthetics | SomePositive |

@NFR
Scenario:   Product's look and feel can be customised
            Which helps user interface aesthetics
\end{minted}
\end{featurecode}
\end{featurelist}

\begin{featurelist}{R74 -- The product will display availability for unreserved conference rooms}{lst:feature_r74}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=false]{Gherkin}


Feature:    R74 - The product will display availability for unreserved conference rooms

            As a Meeting Organiser
            I want to see status for all unreserved conference rooms
            So that I am able to chose the best room for a meeting
	
Constrained by:
            | Learnability | Help |
            | Operability  | Help |
            | Pleasure     | Help |			

@NFR	
Scenario:   Product allows intuitive searching of all unreserved conference rooms
            Which helps Learnability

@NFR	
Scenario:   90% of users are able to see status for all unreserved conference rooms \
            within 5 minutes of product use
            Which helps Operability
	
Scenario:   It is easy to see status for all unreserved conference rooms
            Which helps Operability
            Contributing to help Pleasure
\end{minted}
\end{featurecode}
\end{featurelist}

\chapter{Gherkin Grammar}
This appendix contains listings of the original~\footnote{~ original extracted from https://github.com/cucumber/gherkin3/blob/master/gherkin.berp} and updated Gherkin grammars in their entirety.

\begin{featurelist}{Original gherkin grammar}{lst:original_gherkin_grammar}
\begin{featurecode}{0.8}
\begin{minted}[breaklines=true]{ebnf}
[
	Tokens -> #Empty, #Comment, #TagLine, #FeatureLine, #BackgroundLine, #ScenarioLine, #ScenarioOutlineLine, #ExamplesLine, #StepLine, #DocStringSeparator, #TableRow, #Language
	IgnoredTokens -> #Comment,#Empty
	ClassName -> Parser
	Namespace -> Gherkin
]


Feature! := Feature_Header Background? Scenario_Definition*
Feature_Header! := #Language? Tags? #FeatureLine Feature_Description

Background! := #BackgroundLine Background_Description Scenario_Step*

// we could avoid defining Scenario_Definition, but that would require regular look-aheads, so worse performance
Scenario_Definition! := Tags? (Scenario | ScenarioOutline)

Scenario! := #ScenarioLine Scenario_Description Scenario_Step*

ScenarioOutline! := #ScenarioOutlineLine ScenarioOutline_Description ScenarioOutline_Step* Examples_Definition+
// after the first "Examples" block, interpreting a tag line is ambiguous (tagline of next examples or of next scenario)
// because of this, we need a lookahead hint, that connects the tag line to the next examples, if there is an examples block ahead
Examples_Definition! [#Empty|#Comment|#TagLine->#ExamplesLine]:= Tags? Examples
Examples! := #ExamplesLine Examples_Description #TableRow #TableRow+

Scenario_Step := Step
ScenarioOutline_Step := Step

Step! := #StepLine Step_Arg?
Step_Arg := (DataTable | DocString)

DataTable! := #TableRow+
DocString! := #DocStringSeparator #Other* #DocStringSeparator

Tags! := #TagLine+

Feature_Description := Description_Helper
Background_Description := Description_Helper
Scenario_Description := Description_Helper
ScenarioOutline_Description := Description_Helper
Examples_Description := Description_Helper

// we need to explicitly mention comment, to avoid merging it into the description line's #Other token
// we also eat the leading empty lines, the tailing lines are not removed by the parser to avoid lookahead, this has to be done by the AST builder
Description_Helper := #Empty* Description? #Comment*
Description! := #Other+
\end{minted}
\end{featurecode}
\end{featurelist}
\begin{featurelist}{Updated gherkin grammar}{lst:updated_gherkin_grammar}
\begin{featurecode}{0.7}
\begin{minted}[breaklines=true]{ebnf}
[
	Tokens -> #Empty, #Comment, #TagLine, #FeatureLine, #BackgroundLine, #ScenarioLine, #ScenarioOutlineLine, #ExamplesLine, #StepLine, #DocStringSeparator, #TableRow, #Language, #WichMayImpact, #ScenarioContribution, #QualityAttributeLine, #AsA_Step, #IWant_Step, #SoThat_Step 
	IgnoredTokens -> #Comment,#Empty
	ClassName -> Parser
	Namespace -> Gherkin
]

Feature! := Feature_Header Background? Feature_Description Scenario_Definition*
Feature_Header! := #Language? Tags? #FeatureLine

Background! := #BackgroundLine Background_Description Scenario_Step*

Feature_Description! := Tags? #AsA_Step #IWant_Step #SoThat_Step WichMayImpact* Quality_Step?
Quality_Step!        := #QualityAttributeLine DataTable

WichMayImpact!		:= #WichMayImpact

// we could avoid defining Scenario_Definition, but that would require regular look-aheads, so worse performance
Scenario_Definition! := Tags? (Scenario | ScenarioOutline)

Scenario! := #ScenarioLine Scenario_Step* ScenarioContribution*

ScenarioContribution! := #ScenarioContribution

ScenarioOutline! := #ScenarioOutlineLine ScenarioOutline_Description ScenarioOutline_Step* Examples_Definition+
// after the first "Examples" block, interpreting a tag line is ambiguous (tagline of next examples or of next scenario)
// because of this, we need a lookahead hint, that connects the tag line to the next examples, if there is an examples block ahead
Examples_Definition! [#Empty|#Comment|#TagLine->#ExamplesLine]:= Tags? Examples
Examples! := #ExamplesLine Examples_Description #TableRow #TableRow+

Scenario_Step := Step
ScenarioOutline_Step := Step

Step! := #StepLine Step_Arg?
Step_Arg := (DataTable | DocString)

DataTable! := #TableRow+
DocString! := #DocStringSeparator #Other* #DocStringSeparator

Tags! := #TagLine+

Background_Description := Description_Helper
Scenario_Description := Description_Helper
ScenarioOutline_Description := Description_Helper
Examples_Description := Description_Helper

// we need to explicitly mention comment, to avoid merging it into the description line's #Other token
// we also eat the leading empty lines, the tailing lines are not removed by the parser to avoid lookahead, this has to be done by the AST builder
Description_Helper := #Empty* Description? #Comment*
Description! := #Other+
\end{minted}
\end{featurecode}
\end{featurelist}

\chapter{GRL Catalogue XSD Schema}
\label{ch:grl_catalogue_schema}
The listing below, contains the XSD schema that is used to generate a class model used by the Gherkin to GRL translator described in chapter~\ref{ch:gherkin_redux}, section~\ref{sec:grl_translator}.

\begin{featurelist}{GRL Catalogue XSD Schema -- Part one}{lst:grl_catalogue_xsd_schema_one}
\begin{featurecode}{.7}
\begin{minted}[breaklines=false]{xml}
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
 <xs:element name="grl-catalog">
  <xs:complexType>
   <xs:sequence>
    <!-- Intentional Elements Definitions -->
	<xs:element name="element-def">
	 <xs:complexType>
	  <xs:sequence>
	   <xs:element maxOccurs="unbounded" minOccurs="0" name="intentional-element">
	    <xs:complexType>
		 <xs:attribute name="id" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="type" type="xs:string" use="required"/>
		 <xs:attribute name="decompositiontype" type="xs:string" use="required"/>
		 <xs:attribute name="name" type="xs:string" use="required"/>
		 <xs:attribute name="description" type="xs:string" use="required"/>
		</xs:complexType>
	   </xs:element>
	  </xs:sequence>
     </xs:complexType>
    </xs:element>
    <!-- End of Intentional Elements Definitions -->
    <!-- GRL Links Definitions -->
    <xs:element name="link-def">
	 <xs:complexType>
	  <xs:sequence>
	  <!-- Dependency -->
	   <xs:element maxOccurs="unbounded" minOccurs="0" name="dependency">
	    <xs:complexType>
		 <xs:attribute name="dependeeid" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="dependerid" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="name" type="xs:string" use="required"/>
		 <xs:attribute name="description" type="xs:string" use="required"/>
		</xs:complexType>
	   </xs:element>
	   <!-- Decomposition -->
	   <xs:element maxOccurs="unbounded" minOccurs="0" name="decomposition">
	    <xs:complexType>
	     <xs:attribute name="srcid" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="destid" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="name" type="xs:string" use="required"/>
		 <xs:attribute name="description" type="xs:string" use="required"/>
		</xs:complexType>
	   </xs:element>

	   <! -- continues next page -->
        
\end{minted}
\end{featurecode}
\end{featurelist}
\clearpage
\begin{featurelist}{GRL Catalogue XSD Schema -- Part two}{lst:grl_catalogue_xsd_schema_two}
\begin{featurecode}{.7}
\begin{minted}[breaklines=false,samepage=true]{xml}
        <! -- continued from previous page -->
        
	   <!--Contribution -->
	   <xs:element maxOccurs="unbounded" minOccurs="0" name="contribution">
		<xs:complexType>
		 <xs:attribute name="srcid" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="destid" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="contributiontype" type="xs:string" use="required"/>
                 <!-- New. Optional for backward compatibility. -->
		 <xs:attribute name="quantitativeContribution" type="xs:integer" use="optional"/>
		 <xs:attribute name="correlation" type="xs:boolean" use="required"/>
		 <xs:attribute name="name" type="xs:string" use="required"/>
		 <xs:attribute name="description" type="xs:string" use="required"/>
		</xs:complexType>
	   </xs:element>
	  </xs:sequence>
	 </xs:complexType>
	</xs:element>
	<!-- End of GRL Link Definitions -->
    <!-- Actor Definitions -->
	<xs:element name="actor-def">
	 <xs:complexType>
	  <xs:sequence>
	   <xs:element maxOccurs="unbounded" minOccurs="0" name="actor">
	    <xs:complexType>
		 <xs:attribute name="id" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="name" type="xs:string" use="required"/>
		 <xs:attribute name="description" type="xs:string" use="required"/>
		</xs:complexType>
	   </xs:element>
	  </xs:sequence>
     </xs:complexType>
    </xs:element>
    <!-- End of Actor Definitions -->
	<!-- Actor-IE Containment Links -->
	<xs:element name="actor-IE-link-def">
	 <xs:complexType>
	  <xs:sequence>
	   <xs:element maxOccurs="unbounded" minOccurs="0" name="actorContIE">
	    <xs:complexType>
		 <xs:attribute name="actor" type="xs:positiveInteger" use="required"/>
		 <xs:attribute name="ie" type="xs:positiveInteger" use="required"/>
		</xs:complexType>
	   </xs:element>
	  </xs:sequence>
     </xs:complexType>
    </xs:element>
    <!-- End of Actor-IE Containment Links -->
   </xs:sequence>
   <!-- GRL catalogue attributes -->
   <xs:attribute name="catalog-name" type="xs:string" use="required"/>
   <xs:attribute name="description" type="xs:string" use="required"/>
   <xs:attribute name="author" type="xs:string" use="required"/>
  </xs:complexType>
 </xs:element>
</xs:schema>
\end{minted}
\end{featurecode}
\end{featurelist}
\end{appendices}

\printbibliography

\end{document}
